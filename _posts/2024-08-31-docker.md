---
layout: post
title: Docker最新超详细版教程
date: 2024-08-31
Author: 
categories: 
tags: [Docker]
comments: false
toc: true
---
Docker

学习重点！

- Docker数据卷
- Docker容器
- Docker Compose
- Docker Swarm （类似于简化版的K8S）
- CI / CD jenkins

# 一、Docker概述

## 1.1 Docker为什么出现?

一款产品： 开发–上线 两套环境！应用环境，应用配置！

开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？

环境配置是十分的麻烦，每一个机器都要部署环境(集群Redis、ES、Hadoop…) !费事费力。

发布一个项目( jar + (Redis MySQL JDK ES) )，项目能不能带上环境安装打包！

之前在服务器配置一个应用的环境 Redis、MySQL、JDK、ES、Hadoop 配置超麻烦了，不能够跨平台。开发环境Windows，最后发布到Linux！

传统：开发jar，运维来做！

现在：开发打包部署上线，一套流程做完！

安卓流程：java — apk —发布（应用商店）—- 张三使用apk一安装即可用！

docker流程： java-jar（环境） — 打包项目带上环境（镜像） — ( Docker仓库：商店）——-下载我们发布的镜像 —- 直接运行即可！

Docker给以上的问题，提出了解决方案！

![1](https://pic.altair288.eu.org/file/08036957f14ea6c47674f.jpg)

Docker的思想就来自于集装箱！

JRE – 多个应用(端口冲突) – 原来都是交叉的！

隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。

Docker通过隔离机制，可以将服务器利用到极致！

本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！

## 1.2 Docker的历史

2010年，几个搞IT的年轻人，就在美国成立了一家公司 dotcloud

做一些 pass 的云计算服务！LXC（Linux Container容器）有关的容器技术！

- Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。
  他们将自己的技术（容器化技术）命名就是 Docker。

Docker刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！

- 开源

2013年，Docker开源！

越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！

2014年4月9日，Docker1.0发布！

**docker为什么这么火？** 十分的轻巧！

在容器技术出来之前，我们都是使用虚拟机技术！

虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！

虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！

- vm : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟
- docker: 隔离，镜像（最核心的环境 4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！
  Docker基于Go语言开发的！开源项目！

docker官网：https://www.docker.com/

文档：https://docs.docker.com/ Docker的文档是超级详细的！

仓库：https://hub.docker.com/ 相当于 github

## 1.3 Docker能做什么？

比较Docker和虚拟机技术的不同：

- 传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件
- 容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以 就轻便了
- 每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响

## 1.4 DevOps(开发、运维)

- 应用更快速的交付和部署

传统：一对帮助文档，安装程序。

Docker：打包镜像发布测试一键运行。

- 更便捷的升级和扩缩容

使用了 Docker之后，我们部署应用就和搭积木一样

项目打包为一个镜像，扩展服务器A！服务器B

- 更简单的系统运维

在容器化之后，我们的开发，测试环境都是高度一致的

- 更高效的计算资源利用

Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨 到极致。

# 二、安装

2.1 Docker的基本组成

![2](https://pic.altair288.eu.org/file/cac007445202f5f770e82.jpg)

一个是Docker的客户端，一个是Docker的主机，一个是Docker的远程仓库：

![3](https://pic.altair288.eu.org/file/c2b963a6461728c33869c.jpg)

构建完之后，我们需要去运行,运行是在docker的服务上面去运行的 ，Docker的守护进程中去运行，首先去镜像中去运行，这个镜像好比是一个Java类模板，运行的时候会产生很多的对象，这些一个个的对象就是我们的镜像

![4](https://pic.altair288.eu.org/file/4da64b20e28fbed1610ba.jpg)

- 镜像（image)：

docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像==>run==>容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。

- 容器(container)：

Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.

启动，停止，删除，基本命令

目前就可以把这个容器理解为就是一个简易的 Linux系统。

- 仓库(repository)：

仓库就是存放镜像的地方！

仓库分为公有仓库和私有仓库。(很类似git)

Docker Hub是国外的。

阿里云…都有容器服务器(配置镜像加速!)

## 2.2 安装Docker

环境准备

Linux要求内核3.0以上

```shell
#linux内核
[root@iZuf65oftugvcjgk2jncyeZ ~]# uname -r
4.18.0-80.11.2.el8_0.x86_64
#linux系统版本
[root@iZuf65oftugvcjgk2jncyeZ ~]# cat /etc/os-release 
NAME="CentOS Linux"
VERSION="8 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="8"
PLATFORM_ID="platform:el8"
PRETTY_NAME="CentOS Linux 8 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:8"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-8"
CENTOS_MANTISBT_PROJECT_VERSION="8"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="8"
```

- 安装

帮助文档：https://docs.docker.com/engine/install/

```shell
#1.卸载旧的版本
yum remove docker \
    docker-client \
    docker-client-latest \
    docker-common \
    docker-latest \
    docker-latest-logrotate \
    docker-logrotate \
    docker-engine
#2.需要的安装包
yum install -y yum-utils
#3.设置镜像仓库
yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo #默认是从国外的，不推荐

#推荐使用国内的
yum-config-manager \
    --add-repo \
    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
#更新yum软件包索引
yum makecache fast
#4.安装docker相关的 docker-ce 社区版 而ee是企业版
yum install docker-ce docker-ce-cli containerd.io
```

此时如果执行 `yum makecache fast`出错的

解决方法：

1.进入/etc/yum.repos.d

cd /etc/yum.repos.d

2.删除相应文件，文件名称对应错误提示中的名称，如：

![5](https://pic.altair288.eu.org/file/adead23aa1c1005f44c40.jpg)

```shell
#5.启动docker
systemctl start docker
#6. 使用docker version查看是否按照成功
docker version
Client: Docker Engine - Community
 Version:           20.10.11
 API version:       1.41
 Go version:        go1.16.9
 Git commit:        dea9396
 Built:             Thu Nov 18 00:36:58 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.11
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.16.9
  Git commit:       847da18
  Built:            Thu Nov 18 00:35:20 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.12
  GitCommit:        7b11cfaabd73bb80907dd23182b9347b4245eb5d
 runc:
  Version:          1.0.2
  GitCommit:        v1.0.2-0-g52b36a2
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
#7. 测试
docker run hello-world
#8.查看一下下载的这个hello-world镜像
docker images
```

了解：卸载Docker

```shell
#1. 卸载依赖
yum remove docker-ce docker-ce-cli containerd.io
#2. 删除资源
rm -rf /var/lib/docker
# /var/lib/docker 是docker的默认工作路径！
```

## 2.3 阿里云镜像加速

1. 登录阿里云找到容器服务
2. 找到镜像加速器

   ![6](https://pic.altair288.eu.org/file/bdc21b869d5c5b7293be3.jpg)
3. 配置使用

```shell
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://78q96cy9.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```

**注：国内镜像都封了，别试了**

回顾HelloWorld流程:

！[7](https://pic.altair288.eu.org/file/9c9dd91d06c77ac155393.jpg)

## 2.4 底层原理

Docker是怎么工作的？

Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访 问！

Docker-Server接收到Docker-Client的指令，就会执行这个命令！

![8](https://pic.altair288.eu.org/file/0130effac98d64b17fb4f.jpg)

**Docker为什么比VM快？**

1. Dokcer有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。
2. docker利用的是宿主机的内核，vm 需要是Guest OS

![9](https://pic.altair288.eu.org/file/839eca02f81dcb0afc22a.jpg)

所以说，新建一个容器的时候，docker 不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载 Guest OS，分钟级别的，而docker 是利用宿主机的操作系统，省略了这个复杂的过程，秒级！

![10](https://pic.altair288.eu.org/file/e2689f8111711d9dffa9c.jpg)

# 三、Docker常用命令

## 3.1 帮助命令

```shell
docker version #显示docker的版本信息。
docker info #显示docker的系统信息，包括镜像和容器的数量
docker 命令 --help #帮助命令
```

帮助文档的地址：https://docs.docker.com/engine/reference/commandline/docker/

## 3.2 镜像命令

```shell
docker images #查看所有本地主机上的镜像 可以使用docker image ls代替
docker search 搜索镜像
docker pull 下载镜像 docker image pull
docker rmi 删除镜像 docker image rm
```

**docker images** 查看所有本地的主机上的镜像

```shell
# docker images
REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
hello-world   latest    d1165f221234   4 months ago   13.3kB
# 解释
REPOSITORY   镜像的仓库源
TAG          镜像的标签
IMAGE ID     镜像的ID
CREATED      镜像的创建时间
SIZE         镜像的大小
# 可选项
  -a, --all             # 列出所有的镜像
  -q, --quiet           # 只显示镜像的id
docker images -aq ＃显示所有镜像的id
# docker search mysql
NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql                             MySQL is a widely used, open-source relation…   11138     [OK]   
mariadb                           MariaDB Server is a high performing open sou…   4221      [OK]   
mysql/mysql-server                Optimized MySQL Server Docker images. Create…   829       [OK]
percona                           Percona Server is a fork of the MySQL relati…   547       [OK]   
phpmyadmin                        phpMyAdmin - A web interface for MySQL and M…   274       [OK]   
centos/mysql-57-centos7           MySQL 5.7 SQL database server                   89               
mysql/mysql-cluster               Experimental MySQL Cluster Docker images. Cr…   88   
# 可选项
--filter=STARS=3000   # 搜索出来的镜像就死starts 大于3000的
# docker search mysql --filter=STARS=3000
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql     MySQL is a widely used, open-source relation…   11138     [OK]   
mariadb   MariaDB Server is a high performing open sou…   4221      [OK]
```

**docker pull** 下载镜像

```shell
# 下载镜像 docker pull 镜像名[:tag]
# docker pull mysql
Using default tag: latest #如果不写tag的话，默认使用的就是latest
latest: Pulling from library/mysql
b4d181a07f80: Pull complete   # 分层下载，docker images核心  联合文件系统
a462b60610f5: Pull complete 
578fafb77ab8: Pull complete 
524046006037: Pull complete 
d0cbe54c8855: Pull complete 
aa18e05cc46d: Pull complete 
32ca814c833f: Pull complete 
9ecc8abdb7f5: Pull complete 
ad042b682e0f: Pull complete 
71d327c6bb78: Pull complete 
165d1d10a3fa: Pull complete 
2f40c47d0626: Pull complete 
Digest: sha256:52b8406e4c32b8cf0557f1b74517e14c5393aff5cf0384eff62d9e81f4985d4b   #签名
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest  #真实地址
# 等价于
docker pull mysql
docker pull docker.io/library/mysql:latest
# 指定版本下载
# docker pull mysql:5.7
5.7: Pulling from library/mysql
b4d181a07f80: Already exists 
a462b60610f5: Already exists 
578fafb77ab8: Already exists 
524046006037: Already exists 
d0cbe54c8855: Already exists 
aa18e05cc46d: Already exists 
32ca814c833f: Already exists 
52645b4af634: Pull complete 
bca6a5b14385: Pull complete 
309f36297c75: Pull complete 
7d75cacde0f8: Pull complete 
Digest: sha256:1a2f9cd257e75cc80e9118b303d1648366bc2049101449bf2c8d82b022ea86b7
Status: Downloaded newer image for mysql:5.7
docker.io/library/mysql:5.7
```

**docker rmi** 删除镜像

```shell
# docker rmi -f 镜像id         # 删除指定的镜像
# docker rmi -f 镜像id 镜像id 镜像id 镜像id   # 删除多个镜像
# docker rmi -f $(docker images -aq)     # 删除全部的镜像
3.3、容器命令
docker run 镜像id 新建容器并启动
docker ps 列出所有运行的容器 docker container list
docker rm 容器id 删除指定容器
docker start 容器id #启动容器
docker restart容器id #重启容器
docker stop 容器id #停止当前正在运行的容器
docker kill 容器id #强制停止当前容器
```

说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习

```shell
docker pull centos
```

![11](https://pic.altair288.eu.org/file/ec40f7510c6c24546cdc3.png)

新建容器并启动

```shell
docker run [可选参数] image
# 参数说明
--name="Name"     容器名字   tomcat01   tomcat02，  用来区分容器
-d                后台方式运行  java常用的nohup
-it               使用交互方式运行，进入容器查看内容
-p                指定容器的端口 -p  8080:8080
    -p   ip:主机端口:容器端口
    -p   主机端口:容器端口（常用）
    -p   容器端口
    容器端口
-p                随机指定端口
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker run -it centos /bin/bash
runc: symbol lookup error: runc: undefined symbol: seccomp_api_get
docker: Error response from daemon: cannot start a stopped process: unknown.
```

直接运行的时候，我们有时候可能会出现错误，此时我们需要新增一下依赖即可。

```shell
yum install libseccomp-devel
```

然后重新运行

```shell
# 测试，启动并进入容器
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker run -it centos /bin/bash
[root@460839d39a28 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
```

我们此时发现，我们的主机名称发生了一些变化，新的这个主机名称，也就是我们的镜像的id:

![12](https://pic.altair288.eu.org/file/28127d38287def03edd4a.png)

```shell
# 从容器中退回主机
[root@460839d39a28 /]# exit
exit
```

![13](https://pic.altair288.eu.org/file/87e9fd9a8f0fa3f0bb58d.jpg)

**列出所有的运行的容器**

```shell
#docker ps命令 #列出当前正在运行的容器
    # 列出当前正在运行的容器
-a  # 列出当前正在运行的容器+带出历史运行过的容器
-n=? # 显示最近创建的容器
-q  # 只显示容器的编号

# 列出当前正在运行的容器
[root@iZuf65oftugvcjgk2jncyeZ /]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
#列出所有正在运行的容器包含历史运行过的容器
[root@iZuf65oftugvcjgk2jncyeZ /]# docker ps -a
CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                       PORTS     NAMES
460839d39a28   centos         "/bin/bash"   6 minutes ago    Exited (127) 2 minutes ago             peaceful_mestorf
cbe729c88d10   centos         "/bin/bash"   6 minutes ago    Created                                dreamy_agnesi
185965df630e   centos         "/bin/bash"   7 minutes ago    Created                                friendly_davinci
127e09783e48   feb5d9fea6a5   "/hello"      57 minutes ago   Created                                hardcore_black
```

**退出容器**

```shell
exit    # 直接容器停止并退出
Ctrl + P + Q # 容器不停止退出
[root@1bdee0b9ffdd /]# docker ps[root@iZuf65oftugvcjgk2jncyeZ /]# clear
[root@iZuf65oftugvcjgk2jncyeZ /]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS              PORTS     NAMES
1bdee0b9ffdd   centos    "/bin/bash"   About a minute ago   Up About a minute             hardcore_khayyam
```

此时我们发现，即使我们退出了容器，但是容器还是在后台运行的

**删除容器**

```shell
docker rm 容器id     # 删除指定容器，不能删除正在运行的容器，如果要强制删除  rm -f
docker rm -f $(docker ps -aq)  # 删除所有的容器
docker ps -a -q | xargs docker rm  # 删除所有的容器
```

**启动和停止容器的操作**

```shell
docker start 容器id     #启动容器
docker restart 容器id  #重启容器
docker stop 容器id      #停止当前正在运行的容器
docker kill 容器id      #强制停止当前容器
```

## 3.4、常用其他命令

### 3.4.1 后台启动容器:

```shell
# 命令 docker  run -d 镜像名！
[root@iZuf65oftugvcjgk2jncyeZ /]# docker run -d centos
6628b8a4eb5562a96213da7e58444554ef0cbf94b717df526072d1cc888812cb
[root@iZuf65oftugvcjgk2jncyeZ /]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
# 问题docker  ps，发现centos停止了
# 常见的坑，docker 容器使用后台运行，就必须要有一个前台进程， docker 发现没有应用，就会自动停止
# nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了
```

### 3.4.2 查看日志

```shell
[root@iZuf65oftugvcjgk2jncyeZ /]# docker logs --help

Usage:  docker logs [OPTIONS] CONTAINER

Fetch the logs of a container

Options:
      --details        Show extra details provided to logs
  -f, --follow         Follow log output
      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)
  -n, --tail string    Number of lines to show from the end of the logs (default "all")
  -t, --timestamps     Show timestamps
      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)

[root@iZuf65oftugvcjgk2jncyeZ /]# docker logs --tf --tail 10 

# 自己编写一段shell脚本
[root@iZuf65oftugvcjgk2jncyeZ /]# docker run -d mysql -c "while true;do echo 666;sleep 1;done;"
41d294333ac2df9b6441f11c467af1c346ed2d243d9a5b02f649318b376c54da

[root@iZuf65oftugvcjgk2jncyeZ /]# docker ps -a
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES
b1177469c5ce   centos    "/bin/bash -c 'while…"   32 seconds ago   Up 31 seconds             stoic_rubin

# 显示日志
-tf        #显示日志
--tail=number     #要显示日志条数
[root@iZuf65oftugvcjgk2jncyeZ /]# docker logs -tf --tail 10 b1177469c5ce
2021-11-30T05:36:35.119212478Z 666
2021-11-30T05:36:36.121208677Z 666
2021-11-30T05:36:37.123249288Z 666
2021-11-30T05:36:38.125155628Z 666
2021-11-30T05:36:39.127012899Z 666
2021-11-30T05:36:40.128800099Z 666
2021-11-30T05:36:41.130658457Z 666
2021-11-30T05:36:42.132566895Z 666
2021-11-30T05:36:43.134436292Z 666
2021-11-30T05:36:44.136354825Z 666
2021-11-30T05:36:45.138181418Z 666
2021-11-30T05:36:46.140294276Z 666
2021-11-30T05:36:47.142204299Z 666
```

### 3.4.3 查看容器中进程信息 ps

```shell
# 命令 docker top 容器id
[root@iZuf65oftugvcjgk2jncyeZ /]# docker top b1177469c5ce
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                44214               44195               0                   13:35               ?                   00:00:00            /bin/bash -c while true;do echo 666;sleep 1;done;
root                44419               44214               0                   13:38               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1
```

### 3.4.4 查看镜像的元数据

我们想要具体的去了解这个镜像里面到底有一些什么东西

```shell
# 命令
docker inspect 容器id
[root@iZuf65oftugvcjgk2jncyeZ /]# docker inspect b1177469c5ce
[
    {
        "Id": "b1177469c5ce2c4dfe615b0291afbb9fcf02c9c8ab7ab47bc0e299a00bb38035",    #我们的显示的docker镜像id只是实际的id的前面部分
        "Created": "2021-11-30T05:35:53.708359857Z",
        "Path": "/bin/bash",
        "Args": [
            "-c",
            "while true;do echo 666;sleep 1;done;"   #循环执行的脚本
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 44214,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2021-11-30T05:35:54.029745023Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6",
        "ResolvConfPath": "/var/lib/docker/containers/b1177469c5ce2c4dfe615b0291afbb9fcf02c9c8ab7ab47bc0e299a00bb38035/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/b1177469c5ce2c4dfe615b0291afbb9fcf02c9c8ab7ab47bc0e299a00bb38035/hostname",
        "HostsPath": "/var/lib/docker/containers/b1177469c5ce2c4dfe615b0291afbb9fcf02c9c8ab7ab47bc0e299a00bb38035/hosts",
        "LogPath": "/var/lib/docker/containers/b1177469c5ce2c4dfe615b0291afbb9fcf02c9c8ab7ab47bc0e299a00bb38035/b1177469c5ce2c4dfe615b0291afbb9fcf02c9c8ab7ab47bc0e299a00bb38035-json.log",
        "Name": "/stoic_rubin",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "host",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/28611847bb66c75b582935c3a2cca2dbfeea7eabf7d6a8e0da30388c39deebc6-init/diff:/var/lib/docker/overlay2/70adc9441b28ca6f085201c6718aec46939adcf4f6923a61974653c08e0bbe54/diff",
                "MergedDir": "/var/lib/docker/overlay2/28611847bb66c75b582935c3a2cca2dbfeea7eabf7d6a8e0da30388c39deebc6/merged",
                "UpperDir": "/var/lib/docker/overlay2/28611847bb66c75b582935c3a2cca2dbfeea7eabf7d6a8e0da30388c39deebc6/diff",
                "WorkDir": "/var/lib/docker/overlay2/28611847bb66c75b582935c3a2cca2dbfeea7eabf7d6a8e0da30388c39deebc6/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "b1177469c5ce",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/bash",
                "-c",
                "while true;do echo 666;sleep 1;done;"
            ],
            "Image": "centos",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.label-schema.build-date": "20210915",
                "org.label-schema.license": "GPLv2",
                "org.label-schema.name": "CentOS Base Image",
                "org.label-schema.schema-version": "1.0",
                "org.label-schema.vendor": "CentOS"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "533c33305e4f20427ea415128fdc117e7888addc50f8dd3c02fff85413614892",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/533c33305e4f",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "a960b772e6ce24aaf872de835ff2d8b82ee439a7364b28d66884b1bbf4377104",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "54e8f3e9829b70b9677cd07b5fddc1a5cc45614885f9ee0037bb80785da84f91",
                    "EndpointID": "a960b772e6ce24aaf872de835ff2d8b82ee439a7364b28d66884b1bbf4377104",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]
```

### 3.4.5 进入当前正在运行的容器

```shell
# 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置
# 命令
docker exec -it 容器id bashShell
# 测试
[root@iZuf65oftugvcjgk2jncyeZ /]# docker exec -it b1177469c5ce /bin/bash
[root@b1177469c5ce /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@b1177469c5ce /]# ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 05:35 ?        00:00:00 /bin/bash -c while true;do echo 666;sleep 1;done;
root         654       0  0 05:46 pts/0    00:00:00 /bin/bash
root         674       1  0 05:46 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1
root         675     654  0 05:46 pts/0    00:00:00 ps -ef


# 方式二
docker attach 容器id
# 测试
[root@iZuf65oftugvcjgk2jncyeZ /]# docker attach 596b80f933ac
666
666
666
。。。。一直在执行刚刚我们创建的那个脚本  
# docker exec    #进入容器后开启一个新的终端，可以在里面操作（常用）
# docker attach  #进入容器正在执行的终端，不会启动新的进程！
```

### 3.4.6 从容器内拷贝到主机上

```shell
docker cp 容器id:容器内路径   目的的主机路径

# 查看当前主机目录下
root@iZuf65oftugvcjgk2jncyeZ ~]# docker ps 
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker ps -a
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker run -it centos /bin/bash
[root@7020acf78fbd /]# [root@iZuf65oftugvcjgk2jncyeZ ~]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES
7020acf78fbd   centos    "/bin/bash"   7 seconds ago   Up 6 seconds             quizzical_austin
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker exec -it 7020acf78fbd /bin/bash
[root@7020acf78fbd /]# ls 
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@7020acf78fbd /]# cd home 
[root@7020acf78fbd home]# ls
#在容器内部新建一个md文件，然后准备在容器外部，将此文件拷贝出来
[root@7020acf78fbd home]# touch test.md
[root@7020acf78fbd home]# ls
test.md

[root@iZuf65oftugvcjgk2jncyeZ ~]# docker cp 7020acf78fbd:/home/test.md /home
[root@iZuf65oftugvcjgk2jncyeZ ~]# ls
[root@iZuf65oftugvcjgk2jncyeZ ~]# cd home
-bash: cd: home: No such file or directory
[root@iZuf65oftugvcjgk2jncyeZ ~]# ls
[root@iZuf65oftugvcjgk2jncyeZ ~]# cd /home
[root@iZuf65oftugvcjgk2jncyeZ home]# ls
test.md
# 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现数据的自动同步 可以实现镜像的home目录和我们的主机的home目录联通
```

# 四、小结

![14](https://pic.altair288.eu.org/file/f88649cb312c1849fed92.jpg)

| 命令    | ch                                                                                           |
| ------- | -------------------------------------------------------------------------------------------- |
| attach  | 当前shell下attach连接指定运行镜像 但是只会进入默认的执行的终端                               |
| build   | 通过Dockerfile定制镜像                                                                       |
| commit  | 提交当前容器为新的镜像                                                                       |
| cp      | 从容器中拷贝指定文件或者目录到宿主机中                                                       |
| create  | 创建一个新的容器，同run 但不启动容器                                                         |
| diff    | 查看docker容器变化                                                                           |
| events  | 从docker服务获取容器实时事件                                                                 |
| exec    | 在已存在的容器上运行命令                                                                     |
| export  | 导出容器的内容流作为一个tar归档文件(对应import)                                              |
| history | 展示一个镜像形成历史                                                                         |
| images  | 列出系统当前镜像                                                                             |
| import  | 从tar包中的内容创建一个新的文件系统映像(对应export)                                          |
| info    | 显示系统相关信息                                                                             |
| inspect | 查看容器详细信息                                                                             |
| kill    | kill指定docker容器                                                                           |
| load    | 从一个tar包中加载一个镜像(对应save)                                                          |
| login   | 注册或者登陆一个docker源服务器                                                               |
| logout  | 从当前Docker registry退出                                                                    |
| logs    | 输出当前容器日志信息                                                                         |
| pause   | 暂停容器                                                                                     |
| port    | 查看映射端口对应的容器内部源端口                                                             |
| ps      | 列出容器列表                                                                                 |
| pull    | 从docker镜像源服务器拉取指定镜像或者库镜像                                                   |
| push    | 推送指定镜像或者库镜像至docker源服务器                                                       |
| rename  | 重命名容器                                                                                   |
| restart | 重启运行的容器                                                                               |
| rm      | 移除一个或者多个容器                                                                         |
| rmi     | 移除一个或多个镜像(无容器使用该镜像才可以删除，否则需要删除相关容器才可以继续或者-f强制删除) |
| run     |                                                                                              |
| search  | 在docker hub中搜索镜像                                                                       |
| start   | 启动容器                                                                                     |
| save    | 保存一个镜像为一个tar包(对应load)                                                            |

# 五、练习

## 5.1安装nginx

```shell
#1. 搜索镜像 search 建议大家去docker hub搜索，可以看到帮助文档
docker search nginx
#2. 拉取镜像 pull
docker pull nginx
#3. 运行测试
# -d 后台运行
# --name 给容器命名
# -p 宿主机端口：容器内部端口
[root@iZuf65oftugvcjgk2jncyeZ /]# docker images
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        latest    ea335eea17ab   12 days ago    141MB
mysql        8.0       b05128b000dd   12 days ago    516MB
mysql        latest    b05128b000dd   12 days ago    516MB
centos       latest    5d0da3dc9764   2 months ago   231MB

#我们通过-d进行后台启动  --name 给我们的容器重新命名  -P 我们容器对外暴露的端口号+
[root@iZuf65oftugvcjgk2jncyeZ /]# docker run -d --name nginx01 -p 3344:80 nginx
ed2c04828c9f1caa30a2b109af2831b0606e7d1b14122ef66a0df1d0e1a71b93
[root@iZuf65oftugvcjgk2jncyeZ /]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED             STATUS          PORTS                  NAMES
ed2c04828c9f   nginx     "/docker-entrypoint.…"   4 seconds ago       Up 3 seconds    0.0.0.0:3344->80/tcp   nginx01
7020acf78fbd   centos    "/bin/bash"              About an hour ago   Up 12 minutes   
# 测试链接
[root@iZuf65oftugvcjgk2jncyeZ /]# curl localhost:3344
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
# 进入容器
[root@iZuf65oftugvcjgk2jncyeZ /]# docker exec -it nginx01 /bin/bash
root@ed2c04828c9f:/# ls
bin  boot  dev  docker-entrypoint.d  docker-entrypoint.sh  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@ed2c04828c9f:/# whereis nginx
nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
root@ed2c04828c9f:/# cd /etc/nginx
root@ed2c04828c9f:/etc/nginx# ls
conf.d  fastcgi_params  mime.types  modules  nginx.conf  scgi_params  uwsgi_params
```

端口暴露示意图：

![15](https://pic.altair288.eu.org/file/e8d9f9217aec4d8ad88fa.jpg)

思考问题：我们每次改动nginx配置文件，都需要进入容器内部？十分的麻烦，我要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改？ -v 数据卷！

## 5.2安装tomcat

```shell
# 官方的使用
docker run -it --rm tomcat:9.0
# 我们之前的启动都是后台，停止了容器之后，容器还是可以查到     docker run -it --rm，一般用来测试，用完就删除
# 下载再启动
docker pull tomcat 
# 启动运行
docker run -d -p 3355:8080 --name tomcat01 tomcat
# 测试访问没有问题
# 进入容器
[root@iZ8vbgc3u6dvwrjyp45lyrZ home]# docker exec -it tomcat01 /bin/bash
# 发现问题：1、linux命令少了，2、没有webapps，阿里云镜像的原因。默认是最小的镜像，所有不必要的都剔除掉了。
# 保证最小可运行的环境
```

思考：如果我们需要部署项目的话，如果我们每次都要进入容器的话是十分麻烦的？如果我们在外部提供了一个映射路径，webapps,那么我们在外部放置项目，就自动同步到内部就好了。

## 5.3部署es+kibana**

- es 暴露的端口很多！
- es 十分消耗内存
- es 的数据一般需要放置到安全目录！挂载

```shell
# --net somenetwork ? 网络配置
# 下载启动elasticsearch（Docker一步搞定）
docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2

#我们可以使用docke stats 来查看cpu的状态
CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT   MEM %     NET I/O   BLOCK I/O   PIDS
#此时我们已经关闭了大部分的进程，为了避免elassicSearch很卡，我们就先关闭其他的全部的端口
#（轻身经历，不要自己尝试去安装，巨卡无比）

# 测试一下es是否成功启动
➜ ~ curl localhost: 9200
{
    "name": "d73ad2f22dd3",
    "cluster_name": "docker-cluster",
    "cluster_uuid": "atFKgANxS8CzgIyCB8PGxA",
    "version": {
        "number": "7.6.2",
        "build_flavor": "default",
        "build_type": "docker",
        "build_hash": "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
        "build_date": "2020-03-26T06:34:37.794943Z",
        "build_snapshot": false,
        "lucene_version": "8.4.0",
        "minimum_wire_compatibility_version": "6.8.0",
        "minimum_index_compatibility_version": "6.0.0-beta1"
    },
    "tagline": "You Know, for Search"
}
# 查看docker容器使用内存情况（每秒刷新，也挺耗内存的一个命令）
➜ ~ docker stats
#关闭，添加内存的限制，修改配置文件 -e 环境配置修改
➜ ~ docker rm -f d73ad2f22dd3
➜ ~ docker run -d --name elasticsearch -p 9200: 9200 -p 9300: 9300 -e
"discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m"
elasticsearch: 7.6.2
#下面的这个是搬用别人的结果
➜ ~ curl localhost: 9200
{
    "name": "b72c9847ec48",
    "cluster_name": "docker-cluster",
    "cluster_uuid": "yNAK0EORSvq3Wtaqe2QqAg",
    "version": {
        "number": "7.6.2",
        "build_flavor": "default",
        "build_type": "docker",
        "build_hash": "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
        "build_date": "2020-03-26T06:34:37.794943Z",
        "build_snapshot": false,
        "lucene_version": "8.4.0",
        "minimum_wire_compatibility_version": "6.8.0",
        "minimum_index_compatibility_version": "6.0.0-beta1"
    },
    "tagline": "You Know, for Search"
}
```

作业：使用kibana连接es？思考网络如何才能连接。

![16](https://pic.altair288.eu.org/file/b1945532b0c73ef735dd9.jpg)

## 5.4 Docker可视化

什么是portainer？
Docker图形化界面管理工具！提供一个后台面板供我们操作！

```shell
# 运行如下命令即可 打开可视化服务    -v是挂在，将里面的数据挂在到我们的本机   后面的这个--privileged=true是授权可以访问，最后的就是安装
docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
```

访问：http://ip:8088/

注册登录之后，我们选择一个本地的链接就可以了。

登录之后，我们就可以看到当前的这个界面，就是我们本地的docker服务了

平时用的很少的，自己测试玩玩就可以了。

Rancher(CI/CD)持续集成和持续部署的时候再用

# 六、Docker镜像讲解

## 6.1 镜像是什么?

**镜像是一种轻量级、可执行的独立软件包**，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括**代码**、**运行时**、**库**、**环境变量**和**配置文件**。

**所有的应用，直接打包docker镜像，就可以直接跑起来！**

如何得到镜像：

- 从远程仓库下载
- 朋友拷贝给你
- 自己制作一个镜像DockerFile

## 6.2 Docker镜像加载原理?

### 6.2.1 UnionFS（联合文件系统）：

Union文件系统（UnionFS）是一种**分层、轻量级并且高性能的文件系统**，它支持对文件系统的修改作为一次提交来一层层的叠加，类似于Git中的一层一层提交的一个概念，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。

特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把文件系统及叠加起来，这样最终的文件系统包含所有底层的文件和目录

我们下载的时候看到的一层一层的那个东西，就是我们的一个UnionFS的一个概念：

![17](https://pic.altair288.eu.org/file/be80bc8173acfb39b665d.jpg)

**分层下载**。

我们打个比方，我们现在下载一个mysql5.7版本的镜像，我们再去下载一个mysql8.0版本的镜像，此时我们看下有什么不同点：

mysql5.7 下载：

![18](https://pic.altair288.eu.org/file/da7b26e40caaa147f111b.jpg)

mysql8.0下载：

![19](https://pic.altair288.eu.org/file/95befe185348b28b28ac2.jpg)

此时我们发现，我们下载的时候，提示了，很多文件已经存在了，那么我们就不需要再去下载，我们只需要下载8.0的一些核心文件就可以了，此时，用到的就是我们的一个联合文件系统的一个东西。极大的节省了内存和空间。

### 6.2.2 Dcoker镜像加载原理

docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。

**bootfs**（boot file system）:主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们电箱的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。

> 这个bootfs就相当我们系统启动时候的引导加载，我们启动的时候，主需要一个内核Kernel，以及一个我们用到的加载器bootloader,加载器加载内核之后，我们的系统就运行起来了，此时系统就会卸载bootfs

**rootfs**（root file system）:在bootfs之上。包含的就是典型Linux 系统中的 /dev，/proc，/bin，/etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。

![20](https://pic.altair288.eu.org/file/fa0dd0bb9933b3a5d26c2.jpg)

- 平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？

```shell
[root@iZuf65oftugvcjgk2jncyeZ /]# docker images 
REPOSITORY              TAG       IMAGE ID                     CREATED SIZE 
mysql 5.7                         8b43c6af2ad0 12 days ago     448MB 
mysql 8.0                         b05128b000dd 12 days ago     516MB 
portainer/portainer     latest    580c0e4e98b0 8 months ago    79.1MB
```

> 对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs。虚拟机是分钟级别，容器是秒级！

## 6.3、分层理解

我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载 ，可能有些层是与我们之前是有一些冲突的，或许也有一些层在我们之前下载镜像的时候已经下载过了，所以我们此时下载的时候，我们看下结果。

![21](https://pic.altair288.eu.org/file/e012002c3c0f255746492.jpg)

思考：为什么Docker镜像要采用这种分层的结构呢？

最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。

查看镜像分层的方式可以通过docker image inspect 命令

```shell
docker inspect redis
```

**最后展示的结果，就是我们所看到的每一层的效果的**

![22](https://pic.altair288.eu.org/file/777dab6e154347b5a99f0.jpg)

理解：

所有的 ``docker镜像``都起始于一个 ``基础镜像层``，当进行修改或者增加新的内容时，就会在当前镜像层之上，创建新的镜像层。

> 举一个简单的例子，加入基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上穿件第二个镜像层；这个就像是windows里面的安全补丁的原理差不多，如果继续添加一个安全补丁，就会创建第三个镜像层。

该镜像当前已经包含3个镜像层，如下图（这只是一个用于演示的很简单的例子）。

![23](https://pic.altair288.eu.org/file/2f48cd4c92b7ca4560665.jpg)

在添加额外的镜像层的同时，镜像始终是保持当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像层包含了来自两镜像层的6个文件。

![24](https://pic.altair288.eu.org/file/4070dd700a9a8f887fcd9.jpg)

上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。

下图总展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层的文件7是文件5的一个更新版本。

> 比如说我们在我们一些基础层当中，原本有了一些环境，比如java、tomcat、maven，然后我们需要再去安装一些redis、mysql或者是python等等，那么我们就只需要在层的概念上，我们添加上一层我们需要添加的环境就可以了，这个是不互相影响的。

![25](https://pic.altair288.eu.org/file/f3e3ec9284f138fb21ae5.jpg)

那么如果我们此时有一个新增的镜像，此时第一层也是基础的java、tomcat、maven等等，那我们此时第一层的时候就不需要去新建一个层，将我们刚刚的那个镜像的第一层的基础，直接拿过来用就可以了。

![26](https://pic.altair288.eu.org/file/2609b24c2e948e25f6b05.jpg)

如果我们的其他层级也不变，那我们也可以直接服用就可以了，如果其他的一些文件发生了一些变化，那我们只需要操作文件就可以，新增挥着修改这一层的文件。所有的镜像都是一步一步的进行分层的

这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新的镜像层添加到镜像当中。

Docker通过存储引擎（新版本采用快照机制）的方式来实心镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。

Linux 上可用的存储引擎有AUFS、Overlay2，Device Maper、Btrfs 以及 ZFS。顾名思义，没种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。

Docker在Windows上仅支持windowsfiler 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW。

下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。

![27](https://pic.altair288.eu.org/file/4f734e465c498acfda990.jpg)

**特点**

Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！

这一层就是我们通常说的容器层，容器之下的都叫镜像层。

![28](https://pic.altair288.eu.org/file/d3bd12a8df2b6bcb92f06.jpg)

我们原本的tomcat只是一个镜像，如果我们在tomcat上执行一些操作的话，我们就会在本来tomcat上新增一层，我们执行的所有的操作都在这里，此时我们将我们的tomcat底层镜像和我们对它的一些操作，依然可以打包成一个大的新的镜像。

![29](https://pic.altair288.eu.org/file/a164d487ee10a3ec28e18.jpg)

## 6.4 commit镜像

```shell
docker commit 提交容器成为一个新的副本
# 命令和git原理类似
docker commit -m="描述信息" -a="作者" 容器id 目标镜像名:[TAG]
```

实战测试：

```shell
# 1、启动一个默认的tomcat
docker run -d -p 8080:8080 tomcat
# 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！
docker exec -it 容器id
# 3、拷贝文件进去
# 4、将操作过的容器通过commit**为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像。
docker commit -m="描述信息" -a="作者" 容器id 目标镜像名:[TAG]docker commit -a="kuangshen" -m="add webapps app" 容器id tomcat02:1.0
```

![30](https://pic.altair288.eu.org/file/9a0034271db8ed902ef49.jpg)

如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比我们我们使用虚拟机的快照。

到了这里才算入门成功！！！！

# 七、容器数据卷

## 7.1 什么是容器卷？

docker的理念回顾

将应用和环境打包成一个镜像！

数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：**数据可以持久化**

MySQL，容器删除了，删库跑路！需求：**MySQL数据可以存储在本地！**

容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！

这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！

![31](https://pic.altair288.eu.org/file/88f0cea7328843dce62c5.jpg)

总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！

## 7.2 使用数据卷

方式一 ：直接使用命令挂载 -v

```shell
-v, --volume list Bind mount a volume
docker run -it -v 主机目录:容器内目录 

#测试案例
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker run -it -v /home/centosTest:/home centos /bin/bash
[root@7ec96a6e11b1 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@7ec96a6e11b1 /]# cd home
[root@7ec96a6e11b1 home]# [root@iZuf65oftugvcjgk2jncyeZ ~]# docker ps
CONTAINER ID   IMAGE                 COMMAND        CREATED          STATUS          PORTS                    NAMES
7ec96a6e11b1   centos                "/bin/bash"    14 seconds ago   Up 13 seconds                            wonderful_babbage
0cbfc2fdebb0   tomcat:8.0            "/bin/bash"    13 hours ago     Up 13 hours     0.0.0.0:3344->8080/tcp   tomcat_cesium
f8e444781a2b   portainer/portainer   "/portainer"   17 hours ago     Up 17 hours     0.0.0.0:8088->9000/tcp   friendly_black

#我们可以通国如下命令查看
docker inspect
```

![32](https://pic.altair288.eu.org/file/e42278192ca4152fd29fc.jpg)

测试文件的同步:

![33](https://pic.altair288.eu.org/file/c2aa42d2254c16d68d357.jpg)

我们此时发现，我们容器内的数据和我们宿主机的挂在地址的数据是同步的。

再来测试！

1. 停止容器
2. 宿主机修改文件
3. 启动容器
4. 容器内的数据依旧是同步的
5. 数据的同步是双向的

![34](https://pic.altair288.eu.org/file/124852cf602ad85ceea04.jpg)

## 7.3 实战：安装MySQL

思考：MySQL的数据持久化的问题

```shell
# 1.获取mysql镜像
# 2.运行容器,需要做数据挂载 
# 3.安装启动mysql，需要配置密码的，这是要注意点！
# 参考官网hub
docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag
#启动我们得
-d 后台运行
-p 端口映射
-v 卷挂载
-e 环境配置  MYSQL_ROOT_PASSWORD mysql启动的时候需要我们手动去配置数据密码
-- name 容器名字
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker run -d -p 3305:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name=mysql01 mysql:8.0
363237d651c59a35ce0069a1b224481eecc4c07ec7dda22f6f86812d7b7d6f59
# 启动成功之后，我们在本地使用navicat来测试一下
# navicat-连接到服务器的3305--和容器内的3306映射
# 在本地测试创建一个数据库，查看一下我们映射的路径是否ok！
```

![35](https://pic.altair288.eu.org/file/f1c7e1b3d9fdefad69ba7.jpg)

![36](https://pic.altair288.eu.org/file/f11cfbedba5a73aaa2c9c.jpg)

此时我们本地连接的时候，我们手动创建了一个数据库，我们去镜像中看下，是否存在一个。此时我们发现，我们的数据在我们的宿主机和容器内都是同时存在的

![37](https://pic.altair288.eu.org/file/b14c53cda46aca9b968c1.jpg)

![38](https://pic.altair288.eu.org/file/21c9a9c3617451221edc2.png)

那么如果我们之后想要去修改mysql的配置文件，我们只需要在挂在的宿主机的文件目录下修改即可。

那如果我们此时有个场景，如果我们把mysql的镜像都删除掉了，那么我们的数据会被删除吗，我们测试下。

![39](https://pic.altair288.eu.org/file/79fad21751397b6c6e766.jpg)

在我们删除完数据之后，我们的容器没有了，但是我们宿主机中的数据依旧是存在的。数据依旧是保存在我们的本地，数据是不会丢失的。这就实现了我们的容器数据持久化功能。

## 7.4 具名和匿名挂载

### 7.4.1 匿名挂载

```shell
-v 容器内路径
# -d  后台启动
# -P 随机端口
# --name 容器命名
# -v 挂载地址
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker run -d -P --name nginx01 -v /etc/nginx nginx
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
eff15d958d66: Already exists 
1e5351450a59: Pull complete 
2df63e6ce2be: Pull complete 
9171c7ae368c: Pull complete 
020f975acd28: Pull complete 
266f639b35ad: Pull complete 
Digest: sha256:097c3a0913d7e3a5b01b6c685a60c03632fc7a2b50bc8e35bcaa3691d788226e
Status: Downloaded newer image for nginx:latest
5277eeef2d08bd10759a69068ae89b4a8c449d08be514cf0822f62d72912567b


# 查看所有数据卷  这些都是匿名的  这就是匿名挂载  就像我们java中去new一个匿名内部类，这个内部类是没有名字的
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker volume ls
DRIVER    VOLUME NAME
local     2c38ac8053ab09fdd8b18ac921b4f08bee0c4789420eb21261dcb3921332e33b
local     2ce495b1fffb7902dc33945543608fa9829bc15753764f548eb823169b7d6362
local     125f78fb872eee7af45cc23cd7224432ab3b0a6425578f90fbf22a44b06cb3e2
local     0155988c6b53246891a663b09b7ff31f4e033845f915ab6cbb435bd32e9d3a11
local     aa9e30b0c9437a528c1142a9ec0bcc44eb81df9a17e3150eec9d919bc1013942
local     fa435dae2195899e60a26aad1f5ed0fb8e9864ac29d5e8ac8330633abf704cf8
```

### 7.4.2 具名挂载

我们重启动一个新的容器，给他命名，然后我们去具体的看下他的volume

```shell
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker run -d -P --name nginx02 -v nginx_hh:/etc/nginx nginx
998a07b58223180bb99e6a57da9d08bf4f6327e62c95a1eb78bde1d23acb29d1
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker volume ls
DRIVER    VOLUME NAME
local     2c38ac8053ab09fdd8b18ac921b4f08bee0c4789420eb21261dcb3921332e33b
local     2ce495b1fffb7902dc33945543608fa9829bc15753764f548eb823169b7d6362
local     125f78fb872eee7af45cc23cd7224432ab3b0a6425578f90fbf22a44b06cb3e2
local     0155988c6b53246891a663b09b7ff31f4e033845f915ab6cbb435bd32e9d3a11
local     aa9e30b0c9437a528c1142a9ec0bcc44eb81df9a17e3150eec9d919bc1013942
local     fa435dae2195899e60a26aad1f5ed0fb8e9864ac29d5e8ac8330633abf704cf8
local     nginx_hh
```

此时我们发现，我们指定的这个nginx__hh卷名，在我们的数据卷列表中可以看到，那么我们如何查看这个卷在哪个目录下面呢

```shell
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker volume inspect nginx_hh
或者
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker inspect nginx_hh
```

![40](https://pic.altair288.eu.org/file/ebade681a97777d4db9f7.jpg)

所有的docker容器内的卷，没有指定目录的情况下都是在

```shell
/var/lib/docker/volumes/xxx/_data
```

![41](https://pic.altair288.eu.org/file/ba64c05307d8bfd7bed7c.png)

我们通过具名挂载可以方便的找到我们的 一个卷，大多数情况使用的是 具名挂载

那么我们是如何确定是具名挂载，还是匿名挂载还是指定路径挂载呢？

- -v 容器内地址 匿名挂载
- -v 卷名:容器内地址 具名挂载
- -v /宿主机路径：容器路径 指定路径挂载

拓展：

通过 -v 容器内路径： ro rw 改变读写权限

- ro readonly 只读
- rw readwrite 可读可写

**一旦设置了容器权限，容器对我们挂载出来的内容就有限定了！**

```shell
docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx
docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx
```

**ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！**

## 7.5 初识Dockerfile

Dockerfile 就是用来构建docker镜像的构建文件！

镜像是如何生成的，我们就可以通过Dockerfile来一步一步的去进行构建，之前我们可以通过commit的方式来创建，现在我们需要通过Dockerfile的方式来进行构建，其实这就是一堆的命令和脚本

通过这个脚本可以生成镜像，镜像是一层一层的，脚本就是一个一个的命令.

我们只需要去写一个一个的Dockerfile的命令去执行一下就可以了。

1. 我们先创建一个dockerfile，名字随便定义

```shell
[root@iZuf65oftugvcjgk2jncyeZ docker-test-volume]# cat dockerfile01 
FROM centos
VOLUME ["volume01","volume02"]
CMD echo "-----end-----"
CMD /bin/bash
# 这里的每个命令，就是镜像的一层！
```

![v2-1e74ae55398383bd5bc89232171c3e67_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/e2x8ts.jpg)

![v2-7997ac95932c84f50129a6450cc39a97_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/e2x696.jpg)

启动自己写的镜像

![v2-40b4956d88bd7ca8690688d57ed5d2f2_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/e2x7k9.jpg)

这个卷和外部有一个同步的目录，我们去看一下，我们简单修改下容器中数据卷目录下，然后看下，宿主机中的目录中是否有新增。

![v2-0fcc5e49530a41425337d92c5acfd34a_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/e2x74s.jpg)

查看一下卷挂载的路径

```shell
docker inspect 容器id
```

![v2-111dab80afd00b11a4344359d97f24a5_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/e2x5kn.jpg)

我们通过如上命令查看到了我们挂载的本地路径，我们测试下，数据是否进行同步，我们在我们自己构建的容器中的volume1中新增一个文件

![v2-3e8b7db56a7d516dddec25f59c54ebe8_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/e2x529.png)

我们再去宿主机的相关目录中查看是否有新的文件生成

![v2-e2dc9adac7742f0984686ec92fdbb38a_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/e2x9sh.png)

此时我们发现，在我们的宿主机当中，也生成了一个对应的文件。

这种方式使用的十分多，因为我们通常会构建自己的镜像！在我们构建镜像的 时候，我们就去指定我们挂载 的目录。

假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名：容器内路径！

## 7.6 数据卷容器

多个MySQL同步数据！

命名的容器挂载数据卷！

我们现在有两个容器，centos01和centos02,我们现在有个需求就是实现01和02的数据同步，一般我们把谁去挂载了谁，我们成为父容器，里面的数据内容就都是同步的了，被挂载的这个父容器，就是我们所谓的数据卷容器。我们可以通过此种方式实现，容器间的共享，或者共享给别人。

![v2-e0582c6dd76ddecc9072d3e862cd7ab5_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/e2x7f0.jpg)

启动3个容器，通过我们刚才自己写的镜像启动,我们依次启动docker01,docker02,docker03

**docker01->docker02->docker03**

![v2-02a81f049a6192874bd399c0959ef421_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/e2x6eq.jpg)

我们在创建第二个容器的时候，我们就需要去指定需要继承的docker01

```shell
--volumes-from list                Mount volumes from the specified container(s)

# 测试，
[root@iZuf65oftugvcjgk2jncyeZ _data]# docker run -it --name dockerTest02 --volumes-from dockerTest01 liuhuanhuan:1.0
```

![v2-773fdf7013c62c8bbe156e260d05a142_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/e2x53r.jpg)

此时我们去dockerTest01中去新增一个文件，看下，我们的dockerTest02中的数据是否同步了

![v2-dbd4fb11cbc842bef60213ec09a8fe31_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/e7po6k.jpg)

此时我们会发现，我们的docerTest01和我们的dockerTest02中的数据是同步的。

我们一旦使用–volumes-from我们就实现了数据的同步挂载，类似我们java中的父类和子类的关系被继承的，我们叫做数据卷容器。如下图所示：

![v2-df293132840e13b35e461fafcf21501e_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ew0ukq.jpg)

我们此时再新建一个dockerTest03，我们也继承与我们的01。此时我们看下，数据是否进行了同步。

```shell
[root@iZuf65oftugvcjgk2jncyeZ /]# docker run -it --name dockerTest03 --volumes-from dockerTest01 liuhuanhuan:1.0
```

此时我们新建了一个dockerTest03，我们再去看下目录下，我们的数据依旧是进行同步的。

![v2-a7abce005d5007b113a98f0f28eb6e15_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ew4hvv.jpg)

此时我们考虑在我们的docerTest03中，新建了一个文件，我们去01和02中查看下，数据是否进行了同步呢。

![v2-a549409f90a97ee0bcfd058cad1ac65f_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ewgm8e.jpg)

此时我们发现，3个容器目录下的数据是进行同步的。

![v2-20a464a2dd6d8781ed1f4a2935d2558a_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ewklt4.jpg)

由于**dockerTest01**是数据容器卷，**dockerTest02**和**dockerTest03**都是基于他的,那么此时我们考虑一个场景，如果我们将**dockerTest01**停掉，或者删除掉这个容器的话，那么docerTest02和dockerTest03中的数据是否还存在呢。

测试下，我们删除这个dockerTest01的这个数据容器，此时我们通过docker ps -a发现已经被全部删除了。

![v2-fb5dd0aa4d6345dce25ed657c09f43ea_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ewpx5c.jpg)

现在已经dockerTest01已经被删除了，那么我们去看下我们的dockerTest02和dockerTest03中的数据是否还在呢？

![v2-a35929baa016d4274a9f75fa2c41243a_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ex68ma.png)

此时我们去dockerTest03中去发现，我们的数据依旧是存在的。nice!!!!!!

这种容器之间的数据共享的机制，其实就是一共**数据备份**的机制，也就是一种**双向拷贝**的概念.

![v2-dcb4c75f1c9141d77cf78703a0fc7684_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/exahfv.jpg)

## 7.7 多个mysql实现数据共享

我们来测试下，新建多个mysql数据容器的创建，此时我们新建了第一个容器：我们新建之后，我们本地连接测试下：

```shell
docker run -it -p 3305:3306 --name mysql01 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:8.0
```

![v2-55431e31838e2f247c6a4a46948714b4_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/exqezw.jpg)

此时我们去新建第二个mysql02容器 由于我们的文件的地址是一样的，所以我们在继承的时候，不需要再去指定相关路径了，我们直接使用就可以了。

```shell
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:8.0
6fffaa5beb7079e3b1bf8e0a103d2170b00ccae10acee29717111248047ba7c5
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker ps
CONTAINER ID   IMAGE             COMMAND                  CREATED          STATUS          PORTS                               NAMES
6fffaa5beb70   mysql:8.0         "docker-entrypoint.s…"   3 seconds ago    Up 3 seconds    33060/tcp, 0.0.0.0:3307->3306/tcp   mysql02
948f73079989   mysql:8.0         "docker-entrypoint.s…"   3 minutes ago    Up 3 minutes    33060/tcp, 0.0.0.0:3305->3306/tcp   mysql01
b1bba449a8b9   liuhuanhuan:1.0   "/bin/sh -c /bin/bash"   26 minutes ago   Up 26 minutes                                       dockerTest03
8f03dc19c94b   liuhuanhuan:1.0   "/bin/sh -c /bin/bash"   40 minutes ago   Up 40 minutes                                       dockerTest02
```

这个时候，我们就可以实现两个容器的数据同步。

**结论：**

容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。因为配置的容器之间的数据一直是相互复制的，直到我们所有继承或者是所有挂载的容器全都删除掉，我们的这个数据卷才会消失。

但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！

# 八、DockerFile

## 8.1 DockerFile介绍

dockerfile 是用来构建docker镜像的文件！命令参数脚本！

构建步骤：

1. 编写一个dockerfile文件
2. docker build 构建称为一个镜像
3. docker run运行镜像
4. docker push发布镜像（DockerHub 、阿里云仓库）

查看下官方地址：

![v2-18ce23ef239a8f335fa6eb8546e44ac0_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/extkti.jpg)

![v2-5dbae6ffeb6946ce7ddd505bcbedd64e_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/exwz37.jpg)

但是很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！

官方既然可以制作镜像，那我们也可以！

## 8.2 DockerFile构建过程

基础知识：

1. 每个保留关键字（指令）都是必须是大写字母
2. 执行从上到下顺序
3. #表示注释
4. 每一个指令都会创建提交一个新的镜像曾，并提交！

![v2-ed35d26a759976c070bf14b504f7d571_720w](https://share.altair288.eu.org/easyimage/i/2024/09/19/ey894l.jpg)

Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！

Docker镜像逐渐成企业交付的标准，必须要掌握！

- DockerFile：构建文件，定义了一切的步骤，源代码
- DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。
- Docker容器：容器就是镜像运行起来提供服务。

## 8.3 DockerFile常用指令

```shell
FROM             # 基础镜像，一切从这里开始构建  centos
MAINTAINER        # 镜像是谁写的， 姓名+邮箱
RUN             # 镜像构建的时候需要运行的命令
ADD             # 步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录
WORKDIR         # 镜像的工作目录
VOLUME             # 挂载的目录
EXPOSE             # 暴露端口配置  和我们的-p一样的
CMD             # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。
ENTRYPOINT         # 指定这个容器启动的时候要运行的命令，可以追加命令
ONBUILD         # 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。
COPY             # 类似ADD，将我们文件拷贝到镜像中
ENV             # 构建的时候设置环境变量！
```

## 8.4 实战测试 构建自己的centos

Docker Hub中 99% 镜像都是从这个基础镜像过来的**FROM scratch** , 然后配置需要的软件和配置来进行的构建

![v2-367414701bb9684c8a29802d1d8ee878_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/eyixbl.jpg)

案例：创建一个自己的centos

我们看下之前的centos的环境：

![v2-2d85dd22c814cb0aed9e49a839053e3a_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/eytjfb.jpg)

1. 编写配置文件

   ```shell
   [root@iZuf65oftugvcjgk2jncyeZ dockerfile]# vim myFirstDockerFile
   [root@iZuf65oftugvcjgk2jncyeZ dockerfile]# cat myFirstDockerFile 
   FROM centos
   MAINTAINER liuhuanhuan<liuhuanhuan96@163.com>

   ENV MYPATH /usr/local
   WORKDIR $MYPATH

   RUN yum -y install vim
   RUN yum -y install net-tools


   EXPOSE 80

   CMD echo $MYPATH
   CMD echo "-----end-----"
   CMD /bin/bash
   ```
2. 通过这个文件构建镜像

```shell
# 命令 docker build -f 文件路径 -t 镜像名:[tag] .
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# docker build -f myFirstDockerFile -t mycentos:1.0 .
```

我们看下build之后的效果：

```shell
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# docker build -f myFirstDockerFile -t mycentos:1.0 .
Sending build context to Docker daemon  2.048kB
Step 1/10 : FROM centos
 ---> 5d0da3dc9764
Step 2/10 : MAINTAINER liuhuanhuan<liuhuanhuan96@163.com>
 ---> Running in 8b9a850e6709
Removing intermediate container 8b9a850e6709
 ---> b451c01f5e46
Step 3/10 : ENV MYPATH /usr/local
 ---> Running in a5ceede1147e
Removing intermediate container a5ceede1147e
 ---> cdb4ec6e6af0
Step 4/10 : WORKDIR $MYPATH
 ---> Running in abc95adef4e1
Removing intermediate container abc95adef4e1
 ---> fadd756f9367
Step 5/10 : RUN yum -y install vim
 ---> Running in 42df864b1bda
CentOS Linux 8 - AppStream                       13 MB/s | 8.1 MB     00:00  
CentOS Linux 8 - BaseOS                         8.0 MB/s | 3.5 MB     00:00  
CentOS Linux 8 - Extras                          16 kB/s |  10 kB     00:00  
Dependencies resolved.
================================================================================
 Package             Arch        Version                   Repository      Size
================================================================================
Installing:
 vim-enhanced        x86_64      2:8.0.1763-16.el8         appstream      1.4 M
Installing dependencies:
 gpm-libs            x86_64      1.20.7-17.el8             appstream       39 k
 vim-common          x86_64      2:8.0.1763-16.el8         appstream      6.3 M
 vim-filesystem      noarch      2:8.0.1763-16.el8         appstream       49 k
 which               x86_64      2.21-16.el8               baseos          49 k

Transaction Summary
================================================================================
Install  5 Packages

Total download size: 7.8 M
Installed size: 30 M
Downloading Packages:
(1/5): gpm-libs-1.20.7-17.el8.x86_64.rpm        1.2 MB/s |  39 kB     00:00  
(2/5): vim-filesystem-8.0.1763-16.el8.noarch.rp 3.6 MB/s |  49 kB     00:00  
(3/5): which-2.21-16.el8.x86_64.rpm             2.4 MB/s |  49 kB     00:00  
(4/5): vim-enhanced-8.0.1763-16.el8.x86_64.rpm   13 MB/s | 1.4 MB     00:00  
(5/5): vim-common-8.0.1763-16.el8.x86_64.rpm     44 MB/s | 6.3 MB     00:00  
--------------------------------------------------------------------------------
Total                                           8.0 MB/s | 7.8 MB     00:00   
warning: /var/cache/dnf/appstream-02e86d1c976ab532/packages/gpm-libs-1.20.7-17.el8.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 8483c65d: NOKEY
CentOS Linux 8 - AppStream                      1.6 MB/s | 1.6 kB     00:00  
Importing GPG key 0x8483C65D:
 Userid     : "CentOS (CentOS Official Signing Key) <security@centos.org>"
 Fingerprint: 99DB 70FA E1D7 CE22 7FB6 4882 05B5 55B3 8483 C65D
 From       : /etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial
Key imported successfully
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                        1/1 
  Installing       : which-2.21-16.el8.x86_64                               1/5 
  Installing       : vim-filesystem-2:8.0.1763-16.el8.noarch                2/5 
  Installing       : vim-common-2:8.0.1763-16.el8.x86_64                    3/5 
  Installing       : gpm-libs-1.20.7-17.el8.x86_64                          4/5 
  Running scriptlet: gpm-libs-1.20.7-17.el8.x86_64                          4/5 
  Installing       : vim-enhanced-2:8.0.1763-16.el8.x86_64                  5/5 
  Running scriptlet: vim-enhanced-2:8.0.1763-16.el8.x86_64                  5/5 
  Running scriptlet: vim-common-2:8.0.1763-16.el8.x86_64                    5/5 
  Verifying        : gpm-libs-1.20.7-17.el8.x86_64                          1/5 
  Verifying        : vim-common-2:8.0.1763-16.el8.x86_64                    2/5 
  Verifying        : vim-enhanced-2:8.0.1763-16.el8.x86_64                  3/5 
  Verifying        : vim-filesystem-2:8.0.1763-16.el8.noarch                4/5 
  Verifying        : which-2.21-16.el8.x86_64                               5/5 

Installed:
  gpm-libs-1.20.7-17.el8.x86_64         vim-common-2:8.0.1763-16.el8.x86_64  
  vim-enhanced-2:8.0.1763-16.el8.x86_64 vim-filesystem-2:8.0.1763-16.el8.noarch
  which-2.21-16.el8.x86_64         

Complete!
Removing intermediate container 42df864b1bda
 ---> d84b4ffa9afb
Step 6/10 : RUN yum -y install net-tools
 ---> Running in 85b0c64b0d12
Last metadata expiration check: 0:00:09 ago on Wed Dec  1 12:42:36 2021.
Dependencies resolved.
================================================================================
 Package         Architecture Version                        Repository    Size
================================================================================
Installing:
 net-tools       x86_64       2.0-0.52.20160912git.el8       baseos       322 k

Transaction Summary
================================================================================
Install  1 Package

Total download size: 322 k
Installed size: 942 k
Downloading Packages:
net-tools-2.0-0.52.20160912git.el8.x86_64.rpm   7.4 MB/s | 322 kB     00:00  
--------------------------------------------------------------------------------
Total                                           763 kB/s | 322 kB     00:00   
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                        1/1 
  Installing       : net-tools-2.0-0.52.20160912git.el8.x86_64              1/1 
  Running scriptlet: net-tools-2.0-0.52.20160912git.el8.x86_64              1/1 
  Verifying        : net-tools-2.0-0.52.20160912git.el8.x86_64              1/1 

Installed:
  net-tools-2.0-0.52.20160912git.el8.x86_64                                 

Complete!
Removing intermediate container 85b0c64b0d12
 ---> 3123875290fe
Step 7/10 : EXPOSE 80
 ---> Running in 30144fe42de8
Removing intermediate container 30144fe42de8
 ---> 802e023a0271
Step 8/10 : CMD echo $MYPATH
 ---> Running in fee95b4dddfc
Removing intermediate container fee95b4dddfc
 ---> eb5650da5a20
Step 9/10 : CMD echo "-----end-----"
 ---> Running in 33d26b8a4fc1
Removing intermediate container 33d26b8a4fc1
 ---> 4f46706ae96a
Step 10/10 : CMD /bin/bash
 ---> Running in 6ad7fa93ddc6
Removing intermediate container 6ad7fa93ddc6
 ---> 735e68690d0a
Successfully built 735e68690d0a
Successfully tagged mycentos:1.0
```

我们看到最后都successful，构建成功了，那么我们就成功的构建了一个我们的自己的镜像。

此时我们启动容器，然后查看下：

```shell
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# docker attach 67aefcac09e1
[root@67aefcac09e1 local]# pwd
/usr/local
```

此时我们会发现，我们进入的就是一个工作目录。就是我们在dockerfile文件中定义的工作目录。此时我们再尝试下ifconfig命令，看下。

```shell
[root@67aefcac09e1 local]# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.4  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:04  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

此时我们发现，**ifconfig**命令可以用了，我们相比较之前的纯净版的centos，我们在构建镜像的 时候，我们就自己下载了很多的镜像。

当我们拿到一个镜像的时候，我们可以通过history的命令查看，我们的这个镜像是怎么一步一步制作起来的。具体的结果如下图。

![v2-cd08d119ccf773b99839a039902f7ff8_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/eyxm91.jpg)

此时就列出了，我们刚刚制作的那个镜像的全部历史记录。

## 8.5 CMD 和 ENTRYPOINT区别

- **`CMD`** 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。
- **`ENTRYPOINT`** 指定这个容器启动的时候要运行的命令，可以追加命令
  测试cmd

```shell
# 编写dockerfile文件
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# vim testCmdDockerFile
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# cat testCmdDockerFile 
FROM centos

CMD ["ls","-a"]
#此时我们就执行一个CMD命令，我们去看下实际的效果

#此时我们开始去构建docker镜像
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# docker build -f testCmdDockerFile -t cmddocker:1.0 .
Sending build context to Docker daemon  3.072kB
Step 1/2 : FROM centos
 ---> 5d0da3dc9764
Step 2/2 : CMD ["ls","-a"]
 ---> Running in acb8129389a9
Removing intermediate container acb8129389a9
 ---> c84db5be03af
Successfully built c84db5be03af
Successfully tagged cmddocker:1.0

# 运行镜像
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# docker run c84db5be03af
.
..
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var

#此时我们发现，他执行的是ls -a的一个命令
#那么如果我们想要追加一个命令-l呢，成为ls -al
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# docker run c84db5be03af -l
docker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: "-l": executable file not found in $PATH: unknown.

# cmd的情况下 -l 替换了CMD["ls","-l"]  又由于 -l不是一个命令   所以出现了报错
#我们需要写一个完整的路径来代替
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# docker run c84db5be03af ls -al
total 0
drwxr-xr-x   1 root root   6 Dec  1 13:16 .
drwxr-xr-x   1 root root   6 Dec  1 13:16 ..
-rwxr-xr-x   1 root root   0 Dec  1 13:16 .dockerenv
lrwxrwxrwx   1 root root   7 Nov  3  2020 bin -> usr/bin
drwxr-xr-x   5 root root 340 Dec  1 13:16 dev
drwxr-xr-x   1 root root  66 Dec  1 13:16 etc
drwxr-xr-x   2 root root   6 Nov  3  2020 home
lrwxrwxrwx   1 root root   7 Nov  3  2020 lib -> usr/lib
lrwxrwxrwx   1 root root   9 Nov  3  2020 lib64 -> usr/lib64
drwx------   2 root root   6 Sep 15 14:17 lost+found
drwxr-xr-x   2 root root   6 Nov  3  2020 media
drwxr-xr-x   2 root root   6 Nov  3  2020 mnt
drwxr-xr-x   2 root root   6 Nov  3  2020 opt
dr-xr-xr-x 105 root root   0 Dec  1 13:16 proc
dr-xr-x---   2 root root 162 Sep 15 14:17 root
drwxr-xr-x  11 root root 163 Sep 15 14:17 run
lrwxrwxrwx   1 root root   8 Nov  3  2020 sbin -> usr/sbin
drwxr-xr-x   2 root root   6 Nov  3  2020 srv
dr-xr-xr-x  13 root root   0 Nov 29 13:52 sys
drwxrwxrwt   7 root root 171 Sep 15 14:17 tmp
drwxr-xr-x  12 root root 144 Sep 15 14:17 usr
drwxr-xr-x  20 root root 262 Sep 15 14:17 var
```

测试ENTRYPOINT

```shell
# 编写dockerfile文件
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# vim testEntryPointDockerFile
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# ls
myFirstDockerFile  testCmdDockerFile  testEntryPointDockerFile
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# cat testEntryPointDockerFile 
FROM centos
ENTRYPOINT ["ls","-a"]
# 开始创建镜像
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# docker build -f testEntryPointDockerFile -t entrypointdocker:1.0 .
Sending build context to Docker daemon  4.096kB
Step 1/2 : FROM centos
 ---> 5d0da3dc9764
Step 2/2 : ENTRYPOINT ["ls","-a"]
 ---> Running in b6acadcc217a
Removing intermediate container b6acadcc217a
 ---> d6152ef85374
Successfully built d6152ef85374
Successfully tagged entrypointdocker:1.0

# 此时我们直接进行run
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# docker run d6152ef85374
.
..
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var

#那么我们再进行一下测试
# 我们的命令，是直接拼接在我们得ENTRYPOINT命令后面的
[root@iZuf65oftugvcjgk2jncyeZ dockerfile]# docker run d6152ef85374 -l
total 0
drwxr-xr-x   1 root root   6 Dec  1 13:26 .
drwxr-xr-x   1 root root   6 Dec  1 13:26 ..
-rwxr-xr-x   1 root root   0 Dec  1 13:26 .dockerenv
lrwxrwxrwx   1 root root   7 Nov  3  2020 bin -> usr/bin
drwxr-xr-x   5 root root 340 Dec  1 13:26 dev
drwxr-xr-x   1 root root  66 Dec  1 13:26 etc
drwxr-xr-x   2 root root   6 Nov  3  2020 home
lrwxrwxrwx   1 root root   7 Nov  3  2020 lib -> usr/lib
lrwxrwxrwx   1 root root   9 Nov  3  2020 lib64 -> usr/lib64
drwx------   2 root root   6 Sep 15 14:17 lost+found
drwxr-xr-x   2 root root   6 Nov  3  2020 media
drwxr-xr-x   2 root root   6 Nov  3  2020 mnt
drwxr-xr-x   2 root root   6 Nov  3  2020 opt
dr-xr-xr-x 104 root root   0 Dec  1 13:26 proc
dr-xr-x---   2 root root 162 Sep 15 14:17 root
drwxr-xr-x  11 root root 163 Sep 15 14:17 run
lrwxrwxrwx   1 root root   8 Nov  3  2020 sbin -> usr/sbin
drwxr-xr-x   2 root root   6 Nov  3  2020 srv
dr-xr-xr-x  13 root root   0 Nov 29 13:52 sys
drwxrwxrwt   7 root root 171 Sep 15 14:17 tmp
drwxr-xr-x  12 root root 144 Sep 15 14:17 usr
drwxr-xr-x  20 root root 262 Sep 15 14:17 var
#我们此时发现，这个命令是最佳到我们需要执行的命令后面的
```

Dockerfile中很多命令都十分的相似，我们需要了解它们的区别，我们最好的学习就是对比他们然后测试效果！

## 8.6 实战：tomcat镜像

1. 准备镜像文件

   准备tomcat 和jdk到当前目录，编写好README.md 文件。

   ![v2-bb8023214453be5b0869700454b9e55a_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ez4ds7.jpg)
2. 编写dokerfile，官方命令为Dockerfile,在我们build的时候会自动寻找这个文件，就不需要-f指定指定的dockerfile文件路径！

   ```shell
   FROM centos   #初始化镜像源
   MAINTAINER liuhuanhuan<liuhuanhuan96@163.com>   #作者，邮箱
   COPY README.md /usr/local/README.md    #文件拷贝
   ADD apache-tomcat-9.0.55.tar.gz /usr/local/   #新增tomcat文件 会自动解压到我们的容器当中
   ADD jdk-8u311-linux-x64.tar.gz /usr/local/    #新增jdk文件 会自动解压到我们的容器当中

   RUN yum -y install vim     #命令安装
   ENV MYPATH /usr/local    # 配置基础环境
   WORKDIR $MYPATH    #配置工作目录
   ENV JAVA_HOME /usr/local/jdk1.8.0_311    # 配置java环境
   ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.55   # 配置tomcat环境
   ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin

   EXPOSE 8080   #暴露外部端口
   CMD /usr/local/apache-tomcat-9.0.55/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.55/logs/catalina.out
   ```
3. 构建镜像

   因为dockerfile命名使用默认命名 因此不用使用-f 指定文件

   ```shell
   docker build -t diytomcat .
   ```
4. 启动镜像

   - -d 后台启动
   - -p 指定外部访问接口
   - -v 数据卷挂载

   ```shell
   [root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker run -d -p 9090:8080 --name tomcat01 -v /home/tomcat/test:/usr/local/apache-tomcat-9.0.55/webapps/test -v /home/   tomcat/logs/:/usr/local/apache-tomcat-9.0.55/logs diytomcat
   ```
5. 访问测试

   当然，此时如果我们需要访问的话，我们还需要去阿里云配置下我们的网络安全组，不然我们是无法正常访问外部接口的

   ![v2-c17c7851e39b432618c1063a2262e9e7_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ezfmhi.jpg)
6. 发布项目(由于做了卷挂载，我们直接在本地编写项目就可以发布了！)

   我们在我们的外部/home/tomcat/test目录下新增几个文件

   **style.css**

   ```css
   body {
       width: 100%;
       height: 100%;
       position: fixed;
       background-color: #5e3434;
   }

   .content {
       position: absolute;
       top: 50%;
       left: 50%;
       transform: translate(-50%, -50%);
       height: 160px;
       overflow: hidden;
       font-family: "Lato", sans-serif;
       font-size: 35px;
       line-height: 40px;
       color: #fff;
   }

   .content_container {
       font-weight: 600;
       overflow: hidden;
       height: 40px;
       padding: 0 40px;
   }

   .content_container:before {
       content: "[";
       left: 0;
   }

   .content_container:after {
       content: "]";
       position: absolute;
       right: 0;
   }

   .content_container:before, .content_container:after {
       position: absolute;
       top: 0;
       color: #a04d16;
       font-size: 42px;
       line-height: 40px;
       -webkit-animation-name: opacity;
               animation-name: opacity;
       -webkit-animation-duration: 2s;
               animation-duration: 2s;
       -webkit-animation-iteration-count: infinite;
               animation-iteration-count: infinite;
   }

   .content_container_text {
       display: inline;
       float: left;
       margin: 0;
   }

   .content_container_list {
       margin-top: 0;
       padding-left: 110px;
       text-align: left;
       list-style: none;
       -webkit-animation-name: change;
               animation-name: change;
       -webkit-animation-duration: 10s;
               animation-duration: 10s;
       -webkit-animation-iteration-count: infinite;
               animation-iteration-count: infinite;
   }

   .content_container_list_item {
       line-height: 40px;
       margin: 0;
   }

   @-webkit-keyframes opacity {
       0%, 100% {
           opacity: 0;
       }

       50% {
           opacity: 1;
       }
   }

   @keyframes opacity {
       0%, 100% {
           opacity: 0;
       }

       50% {
           opacity: 1;
       }
   }

   @-webkit-keyframes change {
       0%, 12.66%, 100% {
           transform: translate3d(0, 0, 0);
       }

       16.66%, 29.32% {
           transform: translate3d(0, -25%, 0);
       }

       33.32%, 45.98% {
           transform: translate3d(0, -50%, 0);
       }

       49.98%, 62.64% {
           transform: translate3d(0, -75%, 0);
       }

       66.64%, 79.3% {
           transform: translate3d(0, -50%, 0);
       }

       83.3%, 95.96% {
           transform: translate3d(0, -25%, 0);
       }
   }

   @keyframes change {
       0%, 12.66%, 100% {
           transform: translate3d(0, 0, 0);
       }

       16.66%, 29.32% {
           transform: translate3d(0, -25%, 0);
       }

       33.32%, 45.98% {
           transform: translate3d(0, -50%, 0);
       }

       49.98%, 62.64% {
           transform: translate3d(0, -75%, 0);
       }

       66.64%, 79.3% {
           transform: translate3d(0, -50%, 0);
       }

       83.3%, 95.96% {
           transform: translate3d(0, -25%, 0);
       }
   }
   ```

   **index.html**

   ```html
   <!DOCTYPE html>
   <html lang="en" >
   <head>
     <meta charset="UTF-8">
     <title>一个动态的文字框动画</title>
     <link rel="stylesheet" href="./style.css">

   </head>
   <body>
   <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
   <div class="content">
     <div class="content_container">
       <p class="content_container_text">
         Hello
       </p>

       <ul class="content_container_list">
         <li class="content_container_list_item">world !</li>
         <li class="content_container_list_item">friend !</li>
         <li class="content_container_list_item">users !</li>
         <li class="content_container_list_item">everybody !</li>
       </ul>
     </div>
   </div>
   </body>
   </html>
   ```

我们再去我们刚刚启动的容器中去查看，是否有文件新增：

![v2-9826919e072c148b54ef66b0a8cd3a9c_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ezjull.png)

此时我们发现有文件新增，那么我们就可以直接在外部访问了。我们看下效果。

![v2-3ed51999f278a36181e9dcc9150cfd57_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ezlkab.jpg)

此时我们发现：项目部署成功，可以直接访问！nice!!!部署项目的这部分，我们可以暂时先告一段落了。

我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！

## 8.7 发布自己的镜像

1. 地址 https://hub.docker.com/ 注册账号
2. 确定这个账号可以登录
3. 登录

   ```shell
   [root@iZuf65oftugvcjgk2jncyeZ test]# docker login --help 

   Usage:  docker login [OPTIONS] [SERVER]

   Log in to a Docker registry.
   If no server is specified, the default is defined by the daemon.

   Options:
     -p, --password string   Password
         --password-stdin    Take the password from stdin
     -u, --username string   Username
   [root@iZuf65oftugvcjgk2jncyeZ test]# docker login -u liuhuanhuan963019
   Password: 
   WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
   Configure a credential helper to remove this warning. See
   https://docs.docker.com/engine/reference/commandline/login/#credentials-store

   Login Succeeded
   ```

   出现如上即可表示我们登录成功了！！！
4. 提交 push镜像.

   ```shell
   # push自己的镜像到服务器上！
   [root@iZuf65oftugvcjgk2jncyeZ test]# docker push diytomcat
   Using default tag: latest
   The push refers to repository [docker.io/library/diytomcat]
   48634880c0b2: Preparing 
   5a27e124f752: Preparing 
   280b959488cc: Preparing 
   ce96dfda7353: Preparing 
   74ddd0ec08fa: Preparing 
   denied: requested access to the resource is denied
   ```

此时提示我们push失败,那么我们去修改下我们的镜像配置，我们给我们的容器新增一个tag标签

```shell
[root@iZuf65oftugvcjgk2jncyeZ test]# docker tag df03f9daf7fc liuhuanhuan963019/diytomcat:1.0
[root@iZuf65oftugvcjgk2jncyeZ test]# docker images
REPOSITORY                    TAG       IMAGE ID       CREATED        SIZE
diytomcat                     latest    df03f9daf7fc   3 days ago     677MB
liuhuanhuan963019/diytomcat   1.0       df03f9daf7fc   3 days ago     677MB
mysql                         8.0       bbf6571db497   4 days ago     516MB
nginx                         latest    f652ca386ed1   4 days ago     141MB
tomcat                        latest    904a98253fbf   2 weeks ago    680MB
centos                        latest    5d0da3dc9764   2 months ago   231MB
portainer/portainer           latest    580c0e4e98b0   8 months ago   79.1MB
```

此时我们再去重新提交下看看：

```shell
[root@iZuf65oftugvcjgk2jncyeZ test]# docker push liuhuanhuan963019/diytomcat:1.0
```

我们看下效果

![v2-5b739d17969086695ad0cf22a540b1de_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ezqoiv.png)

此时提交的时候也是一层一层的去进行提交的，我们等待片刻，即可push成功了。

```shell
# 会发现push不上去，因为如果没有前缀的话默认是push到 官方的library
# 解决方法
# 第一种 build的时候添加你的dockerhub用户名，然后在push就可以放到自己的仓库了
$ docker build -t chengcoder/mytomcat:0.1 .
# 第二种 使用docker tag #然后再次push
$ docker tag 容器id chengcoder/mytomcat:1.0 
#然后再次push
$ docker push kuangshen/tomcat:1.0
```

![v2-eee880485bb51e0e3f28a31d43f66218_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f01sr1.jpg)

提交的时候也是按照镜像的层级来提交的！

## 8.8 发布阿里云镜像服务上

1. 登录阿里云
2. 找到容器镜像服务 之前我们配置过镜像加速，现在我们需要去实际运用下镜像仓库。
3. 创建命名空间

   ![v2-64a6d34ea83d5af11eac7e3708d325b6_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f0942k.png)
4. 创建容器镜像

   ![v2-7fe4918e4f1149cb81793ae64feb4161_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f0cuq9.jpg)

   然后选择我们本地仓库就可以了。

   ![v2-64a6d34ea83d5af11eac7e3708d325b6_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f0942k.png)

   点开我们查看下具体的具体的使用方式：

   ![v2-63f48a3450116fbb3ff28da4c14d619b_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f0t1k4.jpg)

   看官网 很详细https://cr.console.aliyun.com/repository/

下面来实战操作下：

- 先登录阿里云的镜像服务

```shell
docker login --username=最爱吃大米1111 registry.cn-shanghai.aliyuncs.com
```

- 然后加标签后开始push

```shell
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker images
REPOSITORY                    TAG       IMAGE ID       CREATED        SIZE
diytomcat                     latest    df03f9daf7fc   3 days ago     677MB
liuhuanhuan963019/diytomcat   1.0       df03f9daf7fc   3 days ago     677MB
mysql                         8.0       bbf6571db497   4 days ago     516MB
nginx                         latest    f652ca386ed1   4 days ago     141MB
tomcat                        latest    904a98253fbf   2 weeks ago    680MB
centos                        latest    5d0da3dc9764   2 months ago   231MB
portainer/portainer           latest    580c0e4e98b0   8 months ago   79.1MB
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker tag df03f9daf7fc xxxx:1.0
```

![v2-d8c3a72ecf2c4ec631088552ba794fd4_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f1crve.png)

此时我们就可以看到我们的镜像已经在push了。

具体操作步骤，看下官方文档会有很详细的步骤：https://cr.console.aliyun.com/repository/cn-shanghai/liuhuanhuan963019/liuhuanhuan963019-test/details

# 九、Docker网络

## 9.1 理解Docker0

1. 清空所有网络

```shell
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker rmi -f $(docker images -aq)
```

获取当前ip地址

```shell
[root@iZuf65oftugvcjgk2jncyeZ ~]# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:16:3e:25:1a:9d brd ff:ff:ff:ff:ff:ff
    inet 172.28.216.81/20 brd 172.28.223.255 scope global dynamic noprefixroute eth0
       valid_lft 314696843sec preferred_lft 314696843sec
3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:18:94:19:89 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
```

三个网络地址**（本机地址、阿里云生成的地址、docker0地址）**

![v2-8d5b6666ba8cb275e6c33d5fb7785318_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f2l1zt.jpg)

此时我们需要去思考一个问题，`docker` 是如果处理容器网络访问的？

比如我现在有一个tomcat容器，还有一个mysql容器，那么 tomcat中的项目，如何去访问mysql容器中的数据呢，`这个链接是写阿里云地址呢，还是写我们的docker地址呢，还是写我们的127.0.0.1呢，我们需要来多多观察下。`我们研究docker网络，主要就是研究这部分的内容的。

![v2-605902f2175e90d46683460bc3a0ce82_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f2odx3.png)

现在我们来运行一个简单的容器，然后看下我们的网络地址变化情况,由于官网现实版本tomcat镜像阉割了很多命令，连基础的yum命令都没有了，所以我们还是使用我们之前的镜像来测试下。

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker exec -it 86f90cc3847b ip addr
```

![v2-cd1e7a5e7f6fc401f33cbdd59a4ed263_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f38ayn.jpg)

在我们启动镜像之后，我们看到了一个 `etho@if175`这样的 地址，这个就是docker给他分配的地址！每个容器都会有一个这样的地址

思考一个问题，linux能不能ping同内部的网络呢？

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# ping 172.17.0.2
```

![v2-de74b6bf0f9f03e6d90552a4f97add91_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f3azye.png)

此时发现我们可以成功的ping通！！！。

**linux是可以ping通docker地址内部地址**

原理

1. 我们每启动一个docker容器，Docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个docker0桥接模式，使用的技术是 veth-pair 技术！

   https://www.cnblogs.com/bakari/p/10613710.html

   再次测试ip addr

   ![v2-a81225f5006dd02680d9553242a83997_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f3obs7.jpg)
2. 在启动一个容器测试，发现又多了一对网络

   ```shell
   [root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker run -d -P --name tomcat02 e2babf72ba72
   ```

   ![v2-6ab34f6c0a5433ec3b5f5fb76cad653c_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f3quk8.jpg)

   我们发现这个容器带来网卡，都是一对对的

   **veth-pair** 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连，正因为有这个特性 veth-pair 充当一个桥梁，连接各种虚拟网络设备的OpenStac,Docker容器之间的  连接，OVS的连接，都是使用evth-pair技术
3. 我们来测试下tomcat01和tomcat02是否可以ping通

通过tomcat01来ping tomcat02

![v2-7b2f41d4a4897ca3ebafdb4ddbf48477_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f3v3ri.jpg)

通过tomcat02来ping tomcat01

![v2-5748705131cfebf73885574fa5a7cbec_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f46a2l.jpg)

此时我们发现都可以互相ping通。

容器与容器之间是可以互相ping通的

![v2-a1a3f8139b6fa1e984ec68af46a79138_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f49pl0.jpg)

**结论**：tomcat01和tomcat02公用一个路由器，docker0。

所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip。

那么我们的这个可用ip有多少个呢。

小结： Docker使用的是Linux的桥接，宿主机是一个Docker容器的网桥 docker0，容器之间想要链接就需要通过vet-pair进行转发，访问。

![v2-577a1ea1bf820c0745f067d090f38c13_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f4e5bs.jpg)

**Docker 中的所有的网络接口都是虚拟的。虚拟的转发效率高！**

只要容器删除，对应网桥一对就没了！

![v2-49579ad7b8b41864fa885d6c96b586f7_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f4gix6.jpg)

思考一个场景：我们编写了一个微服务，database url=ip: ，项目不重启，数据库ip换了，我们希望可以处理这个问题，可以通过名字来进行访问容器？

## 9.2 --link

思考一个场景：我们编写了一个微服务，database url=ip: ，项目不重启，数据库ip换了，我们希望可以处理这个问题，可以通过名字来进行访问容器？

我们使用刚刚创建的两个容器，使用tomcat01 来 ping tomcat02看看，是否能ping通呢？

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker exec -it tomcat01 ping tomcat02
ping: tomcat02: Name or service not known
```

此时我们发现根本ping不同，那我们尝试着去解决这个问题。

我们重新启动一个tomcat容器,使用--link的方式进行启动，然后尝试去ping下：

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker run -d -P --name tomcat03 --link tomcat02 diytomcat
```

![v2-83ed0e30212c2f559fde01f12f9dd18b_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f5g738.png)

此时我们惊奇的发现，可以通过来ping通了！！！之后我们就可以通过--link的方式进行操作，就不要操作ip地址，即可访问了

此时我们启动**tomcat03**的时候，我们 `–link`链接的是**tomcat02**,所以我们可以通过**tomcat03**来直接ping **tomcat02**,那么如果我们进行反向操作呢？尝试下

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker exec -it tomcat02 ping tomcat03
ping: tomcat03: Name or service not known
```

此时我们发现，反向`ping的时候根本ping不通，我们去查看下为什么？通过network可以查看

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker network --help

Usage:  docker network COMMAND

Manage networks

Commands:
  connect     Connect a container to a network
  create      Create a network
  disconnect  Disconnect a container from a network
  inspect     Display detailed information on one or more networks
  ls          List networks
  prune       Remove all unused networks
  rm          Remove one or more networks

Run 'docker network COMMAND --help' for more information on a command.
```

我们可以用通过ls查看我们前的一些网络信息。

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker network ls
NETWORK ID     NAME      DRIVER    SCOPE   
54e8f3e9829b   bridge    bridge    local   #这是系统默认的桥接的 这个就是docker0
fec761935499   host      host      local
af96498edc1e   none      null      local
```

我们来看下这个第一个bridge的这个网络配置

![v2-eac48d9f98ffcf9bd2367c84d42c7a09_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f5je4p.jpg)

以下是我们的启动的3个容器的地址，在我们没有指定ip的时候，会给我们的容器自动分配ip地址。

![v2-6e3748e7cd8c4e1d0d42d532a1f9ff9d_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f5m3eo.jpg)

刚刚我们启动tomcat03的时候通过--link的方式绑定了我们的tomcat02。

本质上其实就是在我们的tomcat03当中配置了`tomcat02的配置，让我们去容器内部去一探究竟。

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker exec -it tomcat03 cat /etc/hosts
127.0.0.1   localhost
::1 localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.17.0.3  tomcat02 8f923b56b788
172.17.0.4  90370f44e98a
```

此时我们惊奇的发现，在我们的tomcat03容器内部的hosts文件，自动配置了tomcat02的ip地址，直接写死了地址，所以说我们tomcat03 ping tomcat02的时候，可以直接ping通.

**本质探究**:--link 本质就是在hosts配置中tomcat02的映射ip地址。

**但是现在使用Docker已经不建议使用–link了！**

**我们需要的是自定义网络！,已经不在适合docker0了！！！**

**主要是因为docker0，已经不在支持容器名进行访问了，我们只需要定义一个网络，让他支持容器名访问就可以了！！！**

## 9.3 自定义网络

```shell
$ docker network --help
connect -- Connect a container to a network
create -- Creates a new network with a name specified by the
disconnect -- Disconnects a container from a network
inspect -- Displays detailed information on a network
ls -- Lists all the networks created by the user
prune -- Remove all unused networks
rm -- Deletes one or more networks
```

上一节中所提到的--link和本章节中所提到的自定义网络，我们都叫做容器互联技术。

我们现在来查看下所有的docker网络

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
54e8f3e9829b   bridge    bridge    local
fec761935499   host      host      local
af96498edc1e   none      null      local
```

**网络模式**

`bridge` ：桥接 docker（默认，自己创建也是使用bridge模式） 主要用的是这个桥接模式

`none` ：不配置网络，一般不用

`host` ：和宿主机共享网络

`container` ：容器网络连通（用得少！局限很大）

**测试桥接模式**

测试之前，我们先删除掉我们全部的容器，保证环境干净

```shell
docker rm -f $(docker ps -aq)
```

![v2-0e8853fc625957cdfb2affca7fd600cf_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f7bzm9.jpg)

我们直接启动的命令 --net bridge,而这个就是我们得docker0 bridge就是我们所说的docker0

```shell
docker run -d -P --name tomcat01 --net bridge tomcat
```

等价于 =>

```shell
docker run -d -P --name tomcat01  tomcat
```

两种实现方式，最后的效果是一样的

docker0特点：**默认，域名不能访问**。 **--link可以打通连接，但是很麻烦！**

我们可以 自定义一个网络，之后我们的服务，就可以在我们的自定义网络下进行使用

```shell
root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
```

- `--driver` bridge
- `-subnet` 192.168.0.0/16 子网 (192.168.0.2-192.168.255.255)
- `--gateway` 192.168.0.1 网关

这个192.168.0.1就类似我们家中所使用的路由器的配置，这就是我们网关的一个概念。

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
3736e3efc939650ab2bb0a082c1a556ba188af22c0ce5747545ef95f9130d691
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
54e8f3e9829b   bridge    bridge    local
fec761935499   host      host      local
3736e3efc939   mynet     bridge    local
af96498edc1e   none      null      local
```

此时发现，我们新建的网络已经创建成功了！！！

我们查看下我们的自己的网络的相关配置：

![v2-76cebd18e890cd257ca74885508ef31d_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f8lgxx.jpg)

既然我们创建了自己的网络，那我们也要来使用下，下面我们来创建两个容器，来看下我们的网络配置

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker run -d -P --name tomcat01 --net mynet diytomcat
e4de5660a3d23287e71b8ff6702e052b146d5626921328b840ae5172bc807dcb
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker run -d -P --name tomcat02 --net mynet diytomcat
78fddd1c9ecc95654fb9dd498738d82004d2617ab65f0d5000098348a24c5baa
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker network inspect mynet 
[
    {
        "Name": "mynet",
        "Id": "3736e3efc939650ab2bb0a082c1a556ba188af22c0ce5747545ef95f9130d691",
        "Created": "2021-12-07T15:55:50.112416535+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "192.168.0.0/16",
                    "Gateway": "192.168.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "78fddd1c9ecc95654fb9dd498738d82004d2617ab65f0d5000098348a24c5baa": {
                "Name": "tomcat02",
                "EndpointID": "e4209762b16c66e8b78dda8cb0014fcdcce447c591ff21ba9fd4881577bc2d68",
                "MacAddress": "02:42:c0:a8:00:03",
                "IPv4Address": "192.168.0.3/16",
                "IPv6Address": ""
            },
            "e4de5660a3d23287e71b8ff6702e052b146d5626921328b840ae5172bc807dcb": {
                "Name": "tomcat01",
                "EndpointID": "f8f96a34ec4a8967a978f1dcef5a4ec6fae484a760d5d54e4a27bb0048c6b9e0",
                "MacAddress": "02:42:c0:a8:00:02",
                "IPv4Address": "192.168.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]
```

此时我们可以清楚的看到，我们指定的地址下面，就有了2个容器。一个是tomcat01 ,一个是tomcat02

![v2-f1b442c1076690c88b8157d98ea32fcb_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/f9kqwe.jpg)

我们此时测试下，通过 `tomcat01`来ping `tomcat02`

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker exec -it tomcat01 ping 192.168.0.3 -c 5
PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.
64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.082 ms
64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.075 ms
64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.074 ms
64 bytes from 192.168.0.3: icmp_seq=4 ttl=64 time=0.078 ms
64 bytes from 192.168.0.3: icmp_seq=5 ttl=64 time=0.076 ms

--- 192.168.0.3 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4091ms
rtt min/avg/max/mdev = 0.074/0.077/0.082/0.003 ms
```

此时我们通过ping容器名称来尝试看下，在我们没有指定--link的情况下，是否可以ping 通过呢?

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker exec -it tomcat01 ping tomcat02 -c 5
PING tomcat02 (192.168.0.3) 56(84) bytes of data.
64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.063 ms
64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.085 ms
64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.094 ms
64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=4 ttl=64 time=0.081 ms
64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=5 ttl=64 time=0.080 ms

--- tomcat02 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4118ms
rtt min/avg/max/mdev = 0.063/0.080/0.094/0.014 ms
```

此时我们发现，依然可以ping通过，这就是使用自定义网络之后的好处！！！

总结：在自定义的网络下，服务可以互相ping通，不用使用–link

 我们自定义的网络docker当我们维护好了对应的关系，推荐我们平时这样使用网络！

好处：

- redis -不同的集群使用不同的网络，保证集群是安全和健康的
- mysql-不同的集群使用不同的网络，保证集群是安全和健康的

![v2-da80b29531852a8a8cd4c7e42391e396_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/fectam.jpg)

## 9.4 网络连通

此时我们考虑一个，使用tomcat-01来ping tomcat-net-01是否可以ping通呢？

![v2-275f3fd8ec024edcb09d4d835fee30e2_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/fegld7.jpg)

实际情况时根本ping不同，这是一个不现实的问题！！！

那我们此时怎么去实现这个操作呢。我们--help查看下

![v2-f7a5006a771a403f6eaaeb619f86708b_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ffi29u.jpg)

这就是我们链接容器的一个核心！！！

![v2-90e291aac28b311a35aef31b920760d1_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/fflf9v.jpg)

此时我们需要去测试连通不同网络下的容器！！！

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker network connect mynet tomcat-01
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker network inspect mynet
```

此时我们看下运行效果:

![v2-6dc28ce677d180cbd098d618a1b5d4a3_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/ffpo6r.jpg)

此时我们搭建连通之后，在我们的自定义网络，我们发现，多了一个我们定义的tomcat-01。连通就是将我们的tomcat-01加入到我们的自定义的网络当中了！！！！

官方俗称：一个容器，两个ip地址。！！！

**简单打个比方，我们现在使用的这个阿里云服务器，有两个ip地址，一个是公网ip，一个是内网ip**

此时我们再去ping尝试下看看:

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker exec -it tomcat-01 ping tomcat01 -c 5
PING tomcat01 (192.168.0.2) 56(84) bytes of data.
64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.083 ms
64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.077 ms
64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.105 ms
64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=4 ttl=64 time=0.080 ms
64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=5 ttl=64 time=0.089 ms

--- tomcat01 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4105ms
rtt min/avg/max/mdev = 0.077/0.086/0.105/0.015 ms
```

成功ping通了！！！！

我们在测试下tomcat-02看看，由于我们没有连通网络，理论上是没法打通的，我们看下实际的效果：

```shell
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker exec -it tomcat-02 ping tomcat01 -c 5
ping: tomcat01: Name or service not known
```

连通失败！！！

结论：假设要跨网络操作别人，就需要使用 docker network connect 连通！

## 9.5 Redis集群实战部署

`用的是分片集群 + 高可用+ 负载均衡`

我们创建6台Redis主机，3台主机，3台从机，为了实现高可用，下面就是做一个备份了，一旦我们的主机挂掉了，那么我们的从机就需要顶上去，代替我们的主机

![v2-259d52ca9548de4703ed5dc517511858_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/fgby2e.jpg)

6个容器，单个启动太慢了，我们选择写一个shell脚本来一键启动：

既然我们要搭建集群的话，那么我们就需要去新建一个Redis的网卡,在此之前，建议还是先清空本地全部的容器，不然1核2G的服务器，卡死可就不好玩咯

```shell
docker rm -f $(docker ps -aq)
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker network create redis --subnet 172.38.0.0/16
5d1b3390482eb00db03573a22da4ad9dfab72ea08e0c0364b6c9be1468f3b43d
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
54e8f3e9829b   bridge    bridge    local
fec761935499   host      host      local
3736e3efc939   mynet     bridge    local
af96498edc1e   none      null      local
5d1b3390482e   redis     bridge    local
[root@iZuf65oftugvcjgk2jncyeZ tomcat]# docker network inspect redis
[
    {
        "Name": "redis",
        "Id": "5d1b3390482eb00db03573a22da4ad9dfab72ea08e0c0364b6c9be1468f3b43d",
        "Created": "2021-12-07T16:51:46.267025951+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.38.0.0/16"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
```

此时我们可以看到，我们新建的这个网卡下面是没有一个网络的！！！现在我们需要区新建容器。

由于Redis我们需要去配置配置文件，我们现在写一个脚本一键去配置：

```shell
# 通过脚本创建六个redis配置
for port in $(seq 1 6);\
do \
mkdir -p /mydata/redis/node-${port}/conf
touch /mydata/redis/node-${port}/conf/redis.conf
cat << EOF >> /mydata/redis/node-${port}/conf/redis.conf
port 6379
bind 0.0.0.0
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 172.38.0.1${port}
cluster-announce-port 6379
cluster-announce-bus-port 16379
appendonly yes
EOF
done
```

执行完脚本之后，我们去看下文件

```shell
[root@iZuf65oftugvcjgk2jncyeZ redis]# ll
total 0
drwxr-xr-x 3 root root 18 Dec  7 19:14 node-1
drwxr-xr-x 3 root root 18 Dec  7 19:14 node-2
drwxr-xr-x 3 root root 18 Dec  7 19:14 node-3
drwxr-xr-x 3 root root 18 Dec  7 19:14 node-4
drwxr-xr-x 3 root root 18 Dec  7 19:14 node-5
drwxr-xr-x 3 root root 18 Dec  7 19:14 node-6
```

通过脚本启动6个redis服务：

```shell
# 通过脚本运行六个redis
for port in $(seq 1 6);\
docker run -p 637${port}:6379 -p 1667${port}:16379 --name redis-${port} \
-v /mydata/redis/node-${port}/data:/data \
-v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf

#单个依次启动
docker run -p 6371:6379 -p 16671:16379 --name redis-1 \
-v /mydata/redis/node-1/data:/data \
-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf

docker run -p 6372:6379 -p 16672:16379 --name redis-2 \
-v /mydata/redis/node-2/data:/data \
-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf

docker run -p 6373:6379 -p 16673:16379 --name redis-3 \
-v /mydata/redis/node-3/data:/data \
-v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf

docker run -p 6374:6379 -p 16674:16379 --name redis-4 \
-v /mydata/redis/node-4/data:/data \
-v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf

docker run -p 6375:6379 -p 16675:16379 --name redis-5 \
-v /mydata/redis/node-5/data:/data \
-v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf

docker run -p 6376:6379 -p 16676:16379 --name redis-6 \
-v /mydata/redis/node-6/data:/data \
-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
```

此时我们看到我们所有的服务已经全部启动起来了！！！

```shell
[root@iZuf65oftugvcjgk2jncyeZ redis]# docker ps
CONTAINER ID   IMAGE                    COMMAND                  CREATED              STATUS              PORTS                                              NAMES
b02ca37755b1   redis:5.0.9-alpine3.11   "docker-entrypoint.s…"   3 seconds ago        Up 3 seconds        0.0.0.0:6376->6379/tcp, 0.0.0.0:16676->16379/tcp   redis-6
b744ec0c8e7b   redis:5.0.9-alpine3.11   "docker-entrypoint.s…"   35 seconds ago       Up 34 seconds       0.0.0.0:6375->6379/tcp, 0.0.0.0:16675->16379/tcp   redis-5
e2d30288447f   redis:5.0.9-alpine3.11   "docker-entrypoint.s…"   About a minute ago   Up About a minute   0.0.0.0:6374->6379/tcp, 0.0.0.0:16674->16379/tcp   redis-4
cb8fcaf83120   redis:5.0.9-alpine3.11   "docker-entrypoint.s…"   About a minute ago   Up About a minute   0.0.0.0:6373->6379/tcp, 0.0.0.0:16673->16379/tcp   redis-3
b88c1bbfb253   redis:5.0.9-alpine3.11   "docker-entrypoint.s…"   2 minutes ago        Up 2 minutes        0.0.0.0:6372->6379/tcp, 0.0.0.0:16672->16379/tcp   redis-2
2c694e4bde3b   redis:5.0.9-alpine3.11   "docker-entrypoint.s…"   4 minutes ago        Up 4 minutes        0.0.0.0:6371->6379/tcp, 0.0.0.0:16671->16379/tcp   redis-1
#redis默认没有bash
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker exec -it redis-1 /bin/sh
/data # ls
appendonly.aof  nodes.conf
```

此时我们成功的进入到我们的redis-1里面了

然后依次创建集群：

```shell
# 创建集群
redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1
```

![v2-70b53b01f4a39231ffd596735a5f826d_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/fhbccf.png)

出现如下即表示集群配置成功！！！

我们看下集群的相关配置：

```shell
# 通过redis-cli -c 进入到集群当中来
/data # redis-cli -c
127.0.0.1:6379>
127.0.0.1:6379> cluster info
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_ping_sent:328
cluster_stats_messages_pong_sent:322
cluster_stats_messages_sent:650
cluster_stats_messages_ping_received:317
cluster_stats_messages_pong_received:328
cluster_stats_messages_meet_received:5
cluster_stats_messages_received:650
127.0.0.1:6379> cluster nodes
46342612ff91a491c74f899d25cc7e1956c435f4 172.38.0.11:6379@16379 myself,master - 0 1638876972000 1 connected 0-5460
cc56770681f898eb9939649e97b405e52b7bac9f 172.38.0.12:6379@16379 master - 0 1638876972977 2 connected 5461-10922
90c01415ccf6437c161840d55a016159cd3f2169 172.38.0.13:6379@16379 master - 0 1638876973078 3 connected 10923-16383
98d60136a3e19f7a324680cf27a81a481d053785 172.38.0.15:6379@16379 slave 46342612ff91a491c74f899d25cc7e1956c435f4 0 1638876971474 5 connected
b097c919d8011f4242536a195d42bc1afabba196 172.38.0.16:6379@16379 slave cc56770681f898eb9939649e97b405e52b7bac9f 0 1638876971976 6 connected
dc89dd2075766c12924b0a5b06286eabf308727b 172.38.0.14:6379@16379 slave 90c01415ccf6437c161840d55a016159cd3f2169 0 1638876972000 4 connected
```

![v2-4f9c6cfc0f3466b85e14729df63a1d08_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/fhhygb.jpg)

现在我们来做一个简单的数据存储来测试下。

```shell
127.0.0.1:6379> set name "lhh"
-> Redirected to slot [5798] located at 172.38.0.12:6379
OK
```

可以看到此时分配的是12这个主机，那么如果当我们12这个主机停掉的时候，那么12的从机，应该顶替上去，这样就可以实现我们的高可用。此时我们在docker中去停掉我们的这个12的这个服务器的端口：

```shell
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker stop b88c1bbfb253
b88c1bbfb253
```

此时我们停掉了redis-2这个容器，那么我们刚刚set的这条数据，我们还能拿到吗

```shell
[root@iZuf65oftugvcjgk2jncyeZ ~]# docker exec -it redis-1 /bin/sh
/data # redis-cli -c
127.0.0.1:6379> get name
-> Redirected to slot [5798] located at 172.38.0.16:6379
"lhh"
172.38.0.16:6379>
```

此时我们停掉了redis-2，那么我们此时对应的丛集redis-6就顶替了之前的redis-2，此时我们依旧是可以查看到我们之前存放的值的。

此时我们再去看下节点：

```shell
172.38.0.16:6379> cluster nodes
cc56770681f898eb9939649e97b405e52b7bac9f 172.38.0.12:6379@16379 master,fail - 1638877301557 1638877300054 2 connected
98d60136a3e19f7a324680cf27a81a481d053785 172.38.0.15:6379@16379 slave 46342612ff91a491c74f899d25cc7e1956c435f4 0 1638877591130 5 connected
b097c919d8011f4242536a195d42bc1afabba196 172.38.0.16:6379@16379 myself,master - 0 1638877589000 7 connected 5461-10922
46342612ff91a491c74f899d25cc7e1956c435f4 172.38.0.11:6379@16379 master - 0 1638877590000 1 connected 0-5460
dc89dd2075766c12924b0a5b06286eabf308727b 172.38.0.14:6379@16379 slave 90c01415ccf6437c161840d55a016159cd3f2169 0 1638877590128 4 connected
90c01415ccf6437c161840d55a016159cd3f2169 172.38.0.13:6379@16379 master - 0 1638877590629 3 connected 10923-16383
```

此时提示我们的redis-2出现主张，我们的redis-6顶替了之前的主机，

docker搭建redis集群完成！

我们使用docker之后，所有的技术都会慢慢变得简单起来！

## 9.6 SpingBoot微服务打包Docker镜像

1. 构建SpringBoot镜像
2. 打包运行

   mvn package

   ![v2-215a1addcd539b0d4298f3611a6f7d58_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/fila9a.png)

   打包成功
3. 编写dockerfile

   ```java
   FROM java:8

   COPY *.jar /app.jar

   CMD ["---server.port=8000"]

   EXPOSE 8000

   ENTRYPOINT ["java","-jar","/app.jar"]
   ```
4. 构建镜像

   ```shell
   # 1.复制jar和DockerFIle到服务器
   # 2.构建镜像
   [root@iZuf65oftugvcjgk2jncyeZ project]# docker build -t springboot .
   ```
5. 发布运行

```shell
[root@iZuf65oftugvcjgk2jncyeZ project]# docker images
REPOSITORY   TAG                IMAGE ID       CREATED         SIZE
springboot   latest             f4de784883a0   2 minutes ago   661MB
diytomcat    latest             e2babf72ba72   6 hours ago     677MB
centos       latest             5d0da3dc9764   2 months ago    231MB
redis        5.0.9-alpine3.11   3661c84ee9d0   19 months ago   29.8MB
java         8                  d23bdf5b1b1b   4 years ago     643MB

[root@iZuf65oftugvcjgk2jncyeZ project]# docker run -d -p 8000:8000 --name springboot01 springboot
```

![v2-db1fd12b3b63f265715ee1873c17c808_r](https://share.altair288.eu.org/easyimage/i/2024/09/19/fjearo.png)

以后我们使用了Docker之后，给别人交付就是一个镜像即可！

## 9.7 总结

### 9.7.1 认识docker

Docker定义：Docker 是一个开源的应用容器引擎，它可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制（ 沙箱是一个虚拟系统程序，沙箱提供的环境相对于每一个运行的程序都是独立的，而且不会对现有的系统产生影响 ），相互之间不会有任何接口，更重要的是容器性能开销极低。

Docker的优点

Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。

Docker应用场景

- Web 应用的自动化打包和发布。
- 自动化测试和持续集成、发布。
- 在服务型环境中部署和调整数据库或其他的后台应用。
- 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。

### 9.7.2 Docker容器与虚拟机

我们用的传统虚拟机如 VMware之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。

而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。

容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。

**Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。**它是目前最流行的 Linux容器解决方案。

Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker ，就不用担心环境问题。

总体来说， Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。

- Docker的几个重要概念，如下图所示：
- 镜像就类似于在创建虚拟机前需要下载的系统镜像文件，比如iso文件、img文件等一些镜像文件。

> 镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是Docker的核心。

- 容器可以类比于正在运行中的虚拟机。
- 你可以将你的镜像save为一个tar文件，别人就可以通过load来获取你的镜像。
- 仓库中则保存了很多公共的常用的镜像，比如常用的JDK镜像、MySQL镜像、tomcat镜像、Ubuntu镜像、ngnix镜像等等。你可以通过pull来拉取获得这些镜像，你也可以自定义一些镜像通过push推送到仓库中。
- Dockerfile就是一个build镜像的文件，它描述并指定了应该如何构建一个镜像。
- Dockerfile 是自动构建 docker 镜像的配置文件， 用户可以使用 Dockerfile 快速创建自定义的镜像。
- Dockerfile 中的命令非常类似于 linux 下的 shell 命令。

一般来说，我们可以将 Dockerfile 分为四个部分：

- 基础镜像(父镜像)信息指令 FROM- 维护者信息指令 MAINTAINER- 镜像操作指令 RUN 、 EVN 、 ADD 和 WORKDIR 等- 容器启动指令 CMD 、 ENTRYPOINT 和 USER 等

### 9.7.3 Docker 命令

| 获取镜像                     | docker pull 镜像名称:版本号                                                |
| ---------------------------- | -------------------------------------------------------------------------- |
| 启动容器                     | 1.docker run -d 镜像名称 （后台启动） 2.docker run -it 镜像名称 (进入容器) |
| 查看容器                     | 1.docker attach 容器id 2.docker exec -it 容器id /bin/bash                  |
| 启动已经停止的容器           | docker ps -a                                                               |
| 停止一个容器                 | docker stop 容器id                                                         |
| 退出容器                     | ctrl + p +q                                                                |
| 导出容器                     | docker save                                                                |
| 导入容器                     | docker load                                                                |
| 删除容器                     | docker rm -f 容器id                                                        |
| 清理掉所有处于终止状态的容器 | docker rm -f $(docker ps-aq)                                               |

### 9.7.4、SpringBoot项目容器化步骤

step1：添加Docker的maven的插件，配置Dockerfile的path；

```xml
<!-- Docker maven plugin -->
<plugin>
    <groupId>com.spotify</groupId>
    <artifactId>docker-maven-plugin</artifactId>
    <version>0.4.13</version>
    <configuration>
        <imageName>${docker.image.prefix}/${project.artifactId}
        </imageName>
        <dockerDirectory>${project.basedir}/src/main/docker</dockerDirectory>
        <resources>
            <resource>
                <targetPath>/</targetPath>
                <directory>${project.build.directory}</directory>
                <include>${project.build.finalName}.jar</include>
            </resource>
        </resources>
    </configuration>
</plugin>
```

step2：在配置的Dockerfile的path处添加Dockerfile文件；

Step3：文件中添加配置：

```java
FROM openjdk:8-jdk-alpine
VOLUME /tmp
#把当前项目下dockertest-0.0.1-SNAPSHOT.jar 改名为test.jar 添加到镜像中
ADD web-app-template-1.0.0.jar test.jar
#指定端口,最好写与项目配置的端口
EXPOSE 8080
#在镜像中运行/test.jar包,这样在运行镜像的时候就已经启动好了test.jar
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/test.jar"]
```

Step4：mvn clean package -Dmaven.test.skip=true （表示不执行测试用例，也不编译测试用例类。）

step5：mvn package docker:build 打镜像

step6：docker images 查看镜像

step7：docker run -p 8081:8081 -t springboot/web-app-template 运行

step8：查看运行结果：http://localhost:8081/….

step9：docker push
